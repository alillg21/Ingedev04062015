#include <string.h>
#include "pri.h"
#include "tst.h"
#include "sys.h"

#ifdef __RSA__
//Unitary test case tcfa0002
//Functions testing:

//  calculateSHA1: This function calculate the hash value using SHA-1 algorithm.
//  SHA1ToPKCS1: This function convert the hashed data to PKCS1 format.
//  rsaSignData: This function sign the data by private key using RSA algorithm.

void tcfa0002(void) {
    int ret;
    byte dBuf[1024];
    tBuffer bBuf;
    trcS("tcfa0002 Beg\n");

    byte PKCS1[128];
    byte *hashIn = (byte *)"\x0E\xD6\xB6\x92\x29\x16\x3B\x58\x6B\x25\x9B\xBC\x8C\x29\x31\x83";   //Sample of Data
    byte hashOut[20];      // must be always 20 bytes
    byte dataIn[128];
    byte dataOut[128];

    byte *p = (byte *)"\xf1\x81\xd6\x11\x4e\x50\x5d\x58\x65\xe5\x83\xb8\xf5\xa9\x20\x2a\x26\x77\x96\x39\x89\x52\x3e\x3f\xa8\x1b\x82\x21\xcf\x02\xab\x31\x73\x5d\xf2\x9d\xed\x2a\x45\x01\x65\x96\x96\x02\x47\xce\xf1\x06\x63\x23\xd0\xf1\x57\xde\x76\x7b\xf3\x4a\x17\xde\x2f\x27\xa0\xd7";   
    byte *q = (byte *)"\xe6\xc1\x18\x17\x7e\x96\x18\x35\xe3\x0e\xa5\x80\x02\xb0\xfb\x37\x4a\xb9\x44\xb3\x1d\x7b\xc6\x8c\x12\xd3\xcb\x38\x52\xe8\xe6\x77\xb9\xad\xa0\x26\x52\xf4\xd3\x0c\x8b\xba\xe5\xc8\x41\x85\x1b\xd7\x2d\x7c\xf4\x5f\xe3\xe9\xf9\xaf\xd9\xcd\x21\xfc\xfc\x56\xba\x8f";
    byte *d = (byte *)"\x91\x20\x8a\xa0\x2e\x5f\xbb\xc0\x36\xaa\xaf\x40\x66\xda\x36\x4b\x64\x03\x08\xa9\xc5\xde\xa1\x03\x62\x52\x5d\x88\xc6\x1d\x08\x31\x6b\x47\xf9\x79\x6a\x28\x6c\x3e\x68\x3e\xfa\x73\x68\x05\xc6\xe9\xa8\xf3\x63\xa1\xa3\x43\xae\xe5\xc9\x3d\x1e\x43\x6e\x30\x30\x0e\x1e\x13\xca\x35\x5b\xad\x84\x7f\x30\x73\xaa\xc5\x76\x04\x0e\x33\xaa\x75\x39\x09\x94\x13\x24\x17\x65\x94\x5f\xcb\xd0\x09\x89\x40\x20\xb6\xca\x96\x63\xec\x69\x6e\xb8\xa0\xf5\x79\xf5\x58\xec\xe1\x34\x5e\x15\xe9\x11\x36\x04\xb3\x7d\x12\x49\x32\x6c\x7c\x77\x23";

    bufInit(&bBuf, dBuf, 1024);
    bufReset(&bBuf);

    ret = dspStart();
    CHECK(ret >= 0, lblKO);
      
    ret = bufApp(&bBuf, hashIn, 16);
    ret = cryCalculateSha1(&bBuf, 16, hashOut); // 16= length of the random string
    CHECK(ret >= 0, lblKO);
    CHECK(memcmp
          (hashOut,
           "\xa6\xaf\x7f\xf3\x85\x04\xbb\x03\x71\x3d\x61\x1c\x2a\xf1\xae\x26\x8d\x14\x36\x37",
           20) == 0, lblKO);

    ret = crySha1ToPkcs1(hashOut, 128, PKCS1);  // 128= size of RSA key in bytes
    CHECK(ret >= 0, lblKO);
    CHECK(memcmp
          (PKCS1,
           "\x00\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x14\xa6\xaf\x7f\xf3\x85\x04\xbb\x03\x71\x3d\x61\x1c\x2a\xf1\xae\x26\x8d\x14\x36\x37",
           128) == 0, lblKO);

    memcpy(dataIn, PKCS1, 128);
    memset(dataOut, 0, 128);

    dspLS(0, "Signing...");   
    tmrPause(1);
    ret = cryRsaSignData(p, q, d, dataIn, dataOut,128);
    CHECK(ret >= 0, lblKO);
    CHECK(memcmp
          (dataOut,
           "\xb6\x6e\x2a\xeb\x86\xfc\x09\xfb\xd4\x2e\x80\x56\x86\xff\x79\x7c\xd8\xbe\x7d\x08\xec\x4b\xc1\x31\xba\x38\x2c\x34\x1c\x7b\xa7\x2b\x28\x42\xad\xb6\xe1\x2f\x68\x62\xf3\xeb\xbf\xac\x78\xa9\xdd\xdd\x85\x0d\x54\x71\x81\x0f\x4a\x5c\xa7\x22\xcf\x8b\x88\x8f\x9b\xc1\x83\xf3\x2f\xa8\x90\x23\xcc\xcb\x8f\xec\x8d\x2e\x69\x9d\xef\x25\x74\xe3\xa8\x0d\x0e\x32\x9c\x34\x3a\x84\xb8\x42\x26\xc1\xd7\x70\xdc\x4e\xdb\x25\x14\xb8\x98\x4d\x41\xe0\x75\x85\x4b\xe0\x37\x42\xd8\x78\x3c\x06\xe6\xe1\xf9\xa8\xab\x9c\x97\x7e\x80\xf0\xe6\xec",
           128) == 0, lblKO);

    dspLS(2, "Data Signed");
    dspLS(3, "Successfully");
    tmrPause(3);
    goto lblEnd;
  lblKO:
  	dspClear();
    dspLS(0, "Error");
    tmrPause(3);
  lblEnd:
  	dspStop();    
    trcS("tcfa0002 End\n");
}
#else
void tcfa0002(void) {}
#endif
