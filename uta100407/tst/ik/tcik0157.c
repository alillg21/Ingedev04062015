//Non-UTA unitary test case for Contactless Telium Pass + device
// connected to i5100 and using PCD library
//Restor Key with KeyB
#include <stdio.h>
#include <unicapt.h>
#include <pcd.h>
#include <string.h>

uint32 displayHandle;
uint32 pcdHandle;               // handle for Contactless reader

static unsigned char NewBlk[16] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // KEY A bitmask
    0xFF, 0x07, 0x80, 0xFF,     // INITIT CONDITIONS
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // KEY B bitmask
};

/*
unsigned char NewBlk[16] = {
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, // KEY A bitmask
		0x08,0x77,0x8F,0xFF,           // 
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // KEY B bitmask
  };
*/

typedef enum ClessCmd {
    CL_Init = 0x0100,
    CL_MsgDsp = 0x0101,
    MF_Open = 0x0220,
    MF_Close,
    MF_Check,
    MF_Detect,
    MF_Activate,
    MF_Auth,
    MF_Read,
    MF_Write,
    MF_Value,
    CL_SCN = 0x03,
    CL_BUZ = 0x0D,
    CL_LED = 0x0e
} ClessCmd_t;

typedef enum ClessPrm {
    PR_Msg_AskCard = 0x9F9300,
    PR_Msg = 0x9F9154,
    PR_DataBlk = 0x9F9414,
    PR_OperType = 0x9F9415,
    PR_DstBlk = 0x9F9416,
    PR_CardIdx = 0x9F941A,
    PR_KeyType = 0x9F9423,
    PR_UncodeKey = 0x9F9424,
    PR_Sector = 0x9F9425,
    PR_DataFmt = 0x9F9426,
    PR_Block = 0x9F9427
} ClessPrm_t;

///Extract highest short from a long
#define H_WORD(C) (unsigned short)(((unsigned long)C&0xFFFF0000UL)>>16)

///Extract lowest word from a card
#define L_WORD(C) (unsigned short)((unsigned long)C&0x0000FFFFUL)

///Extract highest byte
#define H_BYTE(W) (unsigned char)(((unsigned short)W&0xFF00)>>8)

///Extract lowest byte
#define L_BYTE(W) (unsigned char)((unsigned short)W&0x00FF)

#define Len_cdmHdr     8
#define Len_cdmStr     12

static uint8 cmdHdr[Len_cdmHdr] =
    { 0x00, 0x90, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00 };
static uint8 cmdStr[Len_cdmStr] =
    { 0x00, 0x90, 0x9F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
static uint8 img1[] = {         ///< image for printing, height of the image in pixels = 32,  width of the image in bytes (regrouping the pixels by 8) = 8 */
    0x00, 0x00, 0x0C, 0x0C, 0xFC, 0xFC, 0x0C, 0x0C, 0x00, 0xFC, 0xFC, 0xCC,
    0x00, 0x38, 0x7C, 0xCC,
    0x9C, 0x18, 0x00, 0x0C, 0x0C, 0xFC, 0xFC, 0x0C, 0x0C, 0x00, 0x00, 0x00,
    0x00, 0xF8, 0xFC, 0x0C,
    0x3C, 0x38, 0x00, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0C,
    0x00, 0x06, 0x0E, 0x0C,
    0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x0F, 0x0C,
    0x0E, 0x06, 0x00, 0x0F, 0x0F, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

};
static uint8 img2[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x70, 0xD0, 0x80, 0xAC, 0xBC, 0x50, 0x24, 0x38, 0x9C,
    0x9C, 0x92, 0x92, 0x9C,
    0x38, 0x20, 0x24, 0x44, 0x9C, 0x00, 0xD0, 0xF0, 0x70, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0x80, 0x80,
    0x40, 0x20, 0xA0, 0xD0, 0x50, 0x50, 0x28, 0x20, 0x04, 0x14, 0x14, 0x16,
    0x96, 0x15, 0x15, 0x35,
    0x29, 0xC8, 0x10, 0xE0, 0xE0, 0x00, 0x00, 0x80, 0x40, 0x40, 0xE0, 0xE0,
    0x99, 0x86, 0x00, 0x00,
    0x03, 0x03, 0x03, 0x30, 0x2C, 0x20, 0xF3, 0xF3, 0x24, 0x00, 0x50, 0x53,
    0x53, 0x04, 0x04, 0xD0,
    0x50, 0x90, 0x90, 0x2C, 0xF3, 0x20, 0x2C, 0x3C, 0x34, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x80, 0x8F, 0x70, 0x70, 0x40, 0x40, 0x80, 0x80, 0x00, 0x40, 0xC0, 0x20,
    0x10, 0xC9, 0x29, 0x29,
    0xF5, 0x76, 0x16, 0x14, 0x14, 0x14, 0x14, 0xA8, 0x28, 0xD0, 0xD0, 0xF0,
    0xE0, 0x40, 0x00, 0x80,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    0xF0, 0x10, 0x18, 0x08, 0xE8, 0x28, 0x14, 0x14, 0x14, 0x10, 0x0A, 0x08,
    0x85, 0x85, 0x66, 0x62,
    0x81, 0x19, 0x40, 0x40, 0x40, 0x00, 0xC8, 0x3C, 0x9A, 0x8B, 0x0D, 0x15,
    0x0D, 0x0E, 0x06, 0x06,
    0x05, 0x85, 0x82, 0x03, 0x01, 0x01, 0x08, 0x88, 0x84, 0xC0, 0x40, 0x40,
    0x60, 0x20, 0xA1, 0x31,
    0xB1, 0xB1, 0x72, 0x32, 0x02, 0xE2, 0xE2, 0xC2, 0x02, 0x40, 0xE4, 0x84,
    0x84, 0x27, 0x47, 0x24,
    0x24, 0x64, 0x64, 0xE4, 0x04, 0x20, 0x42, 0x42, 0x02, 0x32, 0x72, 0x62,
    0xE1, 0xE1, 0xC1, 0xD1,
    0x80, 0x80, 0x00, 0x0C, 0xFC, 0xF0, 0x00, 0x18, 0x19, 0x01, 0xC3, 0xC3,
    0xC6, 0x85, 0x05, 0x05,
    0x0E, 0x1F, 0x35, 0x6D, 0xCF, 0x9F, 0x30, 0xD0, 0xB0, 0x38, 0x38, 0x78,
    0xF0, 0x91, 0x83, 0x22,
    0x22, 0x05, 0x0D, 0x0A, 0x1A, 0x54, 0x54, 0x14, 0x28, 0x28, 0xF8, 0x38,
    0x10, 0xD0, 0x00, 0x00,

    0x00, 0x1F, 0xFF, 0xF0, 0x1F, 0xF0, 0x12, 0xA6, 0xAC, 0x68, 0xD1, 0xB6,
    0x48, 0x59, 0x17, 0x06,
    0xE0, 0x1C, 0x01, 0xF8, 0xFC, 0x87, 0x3C, 0x06, 0x00, 0xC0, 0xC0, 0xC0,
    0x00, 0x00, 0x00, 0x00,
    0x18, 0x98, 0x21, 0x10, 0x18, 0x18, 0x1B, 0x07, 0x8E, 0x8C, 0x99, 0x99,
    0x31, 0x63, 0x60, 0xC1,
    0xC5, 0x04, 0x30, 0x32, 0x00, 0x1F, 0x7F, 0xFF, 0x80, 0x00, 0x0F, 0x7D,
    0x71, 0x00, 0x0C, 0x8C,
    0xC0, 0xC0, 0x80, 0x1F, 0x7C, 0x00, 0xBC, 0xFC, 0xF0, 0xF0, 0x9A, 0x18,
    0x0C, 0x8C, 0x8C, 0x06,
    0x33, 0x11, 0x10, 0x00, 0x80, 0xFF, 0xC0, 0x80, 0xC8, 0xC8, 0x81, 0xFF,
    0x21, 0x09, 0x5B, 0x73,
    0x27, 0x06, 0x8C, 0x38, 0xF8, 0xE0, 0x03, 0xFC, 0xC1, 0x1E, 0x3E, 0xFC,
    0x00, 0x00, 0x00, 0x1C,
    0x5C, 0x78, 0x20, 0x90, 0x00, 0x08, 0x08, 0x08, 0x82, 0xFE, 0x07, 0xFC,
    0xFC, 0x03, 0x00, 0x00,

    0x00, 0x00, 0x03, 0x03, 0x1C, 0x61, 0x8E, 0x3A, 0x30, 0x85, 0x07, 0x6A,
    0xAD, 0x95, 0x94, 0xC0,
    0x4F, 0x70, 0x80, 0x8F, 0x6F, 0x70, 0x9E, 0x70, 0x9C, 0x9C, 0x38, 0x30,
    0x62, 0x22, 0x20, 0x20,
    0x30, 0x11, 0x1B, 0x9B, 0xCF, 0xEF, 0x67, 0x10, 0x18, 0xF8, 0xEC, 0x8C,
    0x84, 0xC6, 0xE2, 0x33,
    0x3B, 0x18, 0x0C, 0x7C, 0xE6, 0xC2, 0xCB, 0xCB, 0xC7, 0xCF, 0xCF, 0xCF,
    0xCF, 0x6E, 0x60, 0x24,
    0xB1, 0x9B, 0x9F, 0xCE, 0xC0, 0x60, 0xE3, 0xF3, 0xB3, 0x13, 0x0B, 0x07,
    0x01, 0xA1, 0xB1, 0x93,
    0x82, 0xC3, 0x63, 0x63, 0x23, 0x13, 0x3F, 0x71, 0xE1, 0xE1, 0xCD, 0x6D,
    0x60, 0x30, 0x30, 0x70,
    0xE1, 0x78, 0x10, 0x02, 0x82, 0x80, 0x60, 0x0F, 0xC3, 0x7C, 0x7C, 0x07,
    0x04, 0x5C, 0x9D, 0x9D,
    0x3C, 0x3C, 0x0C, 0x4C, 0xA0, 0xE0, 0xF8, 0x3C, 0xC7, 0x70, 0x0F, 0x0F,
    0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x0E, 0x0C, 0x13, 0x24,
    0x59, 0x1B, 0xB2, 0xE6,
    0x4E, 0x98, 0xB1, 0x27, 0x26, 0x0C, 0x91, 0xA2, 0xC4, 0xCD, 0x8B, 0x13,
    0x29, 0x50, 0xA0, 0xA1,
    0xC1, 0x43, 0x83, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE1, 0xE1,
    0xF1, 0x19, 0x08, 0x08,
    0x18, 0x18, 0x18, 0x03, 0x00, 0xF8, 0xF8, 0xF8, 0xC8, 0xD8, 0xF8, 0xF8,
    0xF8, 0x81, 0x01, 0xF1,
    0xF9, 0x19, 0x19, 0x08, 0x18, 0x18, 0xF8, 0xF9, 0xE1, 0x03, 0x3B, 0x7B,
    0x69, 0xE9, 0xC9, 0xD9,
    0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80,
    0xC0, 0x60, 0x23, 0xA3,
    0xD3, 0x48, 0x24, 0xD3, 0xDB, 0xC9, 0x4C, 0x67, 0x79, 0x00, 0x00, 0x00,
    0x80, 0xF8, 0x50, 0xE0,
    0xE6, 0x7E, 0x38, 0x16, 0x09, 0x0C, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x01, 0x02, 0x02, 0x05, 0x05, 0x01, 0x0A, 0x0A, 0x10, 0x14, 0x14, 0x25,
    0x29, 0x2A, 0x28, 0x2C,
    0x5C, 0x59, 0x5A, 0xBB, 0xB7, 0xB7, 0xB6, 0xBA, 0x6C, 0x54, 0x50, 0x58,
    0xAB, 0xAE, 0xD6, 0xD6,
    0x97, 0x97, 0xA3, 0x20, 0x00, 0x47, 0x47, 0x47, 0x06, 0x86, 0x86, 0x87,
    0x87, 0x03, 0x00, 0x01,
    0x07, 0x06, 0x06, 0x86, 0x86, 0x06, 0x43, 0x43, 0x41, 0x00, 0x23, 0x27,
    0xA6, 0xE6, 0xD6, 0xD7,
    0xCB, 0xA8, 0xA8, 0xA8, 0x54, 0x54, 0xCA, 0xEA, 0xA5, 0xA5, 0xA5, 0xA6,
    0x57, 0x55, 0x5C, 0x5E,
    0x2A, 0x2B, 0x29, 0x25, 0x35, 0x15, 0x16, 0x0A, 0x0A, 0x05, 0x05, 0x05,
    0x02, 0x02, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
    0x01, 0x09, 0x1F, 0x22,
    0x22, 0x06, 0x0C, 0x23, 0x3E, 0x20, 0x20, 0x10, 0x10, 0x08, 0x04, 0x08,
    0x08, 0x09, 0x11, 0x31,
    0x11, 0x08, 0x08, 0x08, 0x04, 0x08, 0x10, 0x10, 0x10, 0x30, 0x3E, 0x21,
    0x0D, 0x0F, 0x02, 0x26,
    0x1F, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

};

const unsigned char ingenico[] =    //128x32
{

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x80, 0x80, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0,
    0xE0, 0xE0, 0xE0, 0xE0,
    0xE0, 0xE0, 0xE0, 0xE0, 0xF0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
    0xE0, 0xE0, 0xE0, 0xE0,
    0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x80, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x80, 0xE0, 0xF0, 0xF8, 0xF8, 0xFC, 0xFC, 0xFC, 0xFE, 0x7E,
    0x3F, 0x1F, 0xF3, 0xFB,
    0xFF, 0x7F, 0x7F, 0xFF, 0x7F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F,
    0xBF, 0x9F, 0x1F, 0x1F,
    0xFF, 0x7F, 0x3F, 0x9F, 0x9F, 0x1F, 0xFF, 0xFF, 0x7F, 0x7F, 0xFF, 0xFF,
    0x7F, 0x3F, 0xFF, 0xFF,
    0xFF, 0x7F, 0x1B, 0xFB, 0xFF, 0x7F, 0x3F, 0xBF, 0x9F, 0xDF, 0xFF, 0x7F,
    0x3F, 0x9F, 0x9E, 0xBE,
    0x3C, 0xFC, 0xFC, 0x9C, 0xB8, 0xF0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x84, 0x84, 0x78, 0x00, 0x00, 0xFC, 0xA4, 0xA4, 0x00,
    0x00, 0x60, 0xC0, 0x18,
    0x04, 0x78, 0xC8, 0x84, 0x84, 0x20, 0x00, 0xFC, 0x04, 0x04, 0xF8, 0x00,
    0x70, 0x80, 0x84, 0xFE,
    0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x07, 0x1F, 0x1F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFD, 0xFE,
    0xE0, 0xE0, 0xF3, 0xF9,
    0xFC, 0xE0, 0xE0, 0xF1, 0xFC, 0xFE, 0xF0, 0xE1, 0x73, 0x39, 0xD0, 0xDB,
    0x79, 0x0D, 0xC0, 0xE6,
    0xF7, 0xE0, 0xE0, 0xE1, 0xE4, 0xF6, 0xFB, 0xF9, 0xE0, 0xE0, 0xF9, 0xF9,
    0xFE, 0xF8, 0xE7, 0xF7,
    0xF8, 0xE0, 0xE7, 0xF7, 0xF1, 0xE0, 0xE7, 0xE7, 0xF7, 0xFB, 0xF0, 0xF0,
    0xE7, 0xE7, 0xF3, 0xF9,
    0xFC, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x1F, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xF8,
    0x08, 0x88, 0xF8, 0x00, 0x40, 0x88, 0x08, 0xF8, 0x00, 0x18, 0x20, 0xC0,
    0x20, 0x02, 0x01, 0x08,
    0x08, 0x18, 0xF8, 0x08, 0x08, 0xE0, 0x00, 0xF8, 0xA8, 0xA8, 0x98, 0x00,
    0xF8, 0x08, 0x08, 0xF8,
    0x00, 0x00, 0xFC, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
    0x03, 0x03, 0x03, 0x03,
    0x07, 0x07, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x1E, 0x1C, 0x1B, 0x1B,
    0x3C, 0x3C, 0x3F, 0x3F,
    0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
    0x3F, 0x3F, 0x1F, 0x1F,
    0x1F, 0x1F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x03,
    0x03, 0x03, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

};

static void tcikPrint(char *txt) {
    uint32 prnHandle;

    prnOpen("DEFAULT", &prnHandle, PRN_IMMEDIATE);
    prnPrint(prnHandle, txt);
    prnClose(prnHandle);
}

static int16 AddPrm(uint8 * cmd, unsigned long PrmId, uint8 * val, int16 len) {
    int16 ret = 0;
    int16 i;

    cmd[0] = L_BYTE(L_WORD(PrmId));
    cmd[1] = H_BYTE(L_WORD(PrmId));
    cmd[2] = L_BYTE(H_WORD(PrmId));
    cmd[3] = 0x00;
    cmd[4] = len;
    cmd[5] = 0x00;
    cmd[6] = 0x00;
    cmd[7] = 0x00;

    i = 0;
    while(len) {
        cmd[8 + i] = val[i];
        len--;
        i++;
    }

    ret = i + 7;

    if(ret < Len_cdmStr)
        ret = Len_cdmStr;
    if(ret % 2)
        ret++;

    return ret;
}

static uint8 Sector, Block;

static int16 buildPrm(uint8 * cmd, unsigned short CmdId) {
    int16 ret = 0;

    switch (CmdId) {
      case MF_Detect:
          ret = AddPrm(&cmd[ret], PR_CardIdx, "\x00", 1);
          break;
      case MF_Auth:
          ret = ret + AddPrm(&cmd[ret], PR_KeyType, "\x60", 1);
          ret = ret + AddPrm(&cmd[ret], PR_Sector, &Sector, 1);
          //ret = ret + AddPrm(&cmd[ret], PR_UncodeKey, "\xBB\xBB\xBB\xBB\xBB\xBB", 6);
          ret =
              ret + AddPrm(&cmd[ret], PR_UncodeKey, "\xFF\xFF\xFF\xFF\xFF\xFF",
                           6);
          break;
      case MF_Read:
          ret = ret + AddPrm(&cmd[ret], PR_DataFmt, "\x02", 1);
          ret = ret + AddPrm(&cmd[ret], PR_Sector, &Sector, 1);
          ret = ret + AddPrm(&cmd[ret], PR_Block, &Block, 1);
          break;
      case MF_Write:
          ret = ret + AddPrm(&cmd[ret], PR_DataFmt, "\x02", 1);
          ret = ret + AddPrm(&cmd[ret], PR_Sector, &Sector, 1);
          ret = ret + AddPrm(&cmd[ret], PR_Block, &Block, 1);
          ret = ret + AddPrm(&cmd[ret], PR_DataBlk, NewBlk, 16);
          break;
      case MF_Value:
          ret = ret + AddPrm(&cmd[ret], PR_OperType, "\xC1", 1);
          //ret = ret + AddPrm(&cmd[ret], PR_DataFmt, "\x02", 1);
          ret = ret + AddPrm(&cmd[ret], PR_Sector, "\x05", 1);
          ret = ret + AddPrm(&cmd[ret], PR_Block, "\x00", 1);
          //ret = ret + AddPrm(&cmd[ret], PR_DstBlk, "\x02", 1);
          //ret = ret + AddPrm(&cmd[ret], PR_DataBlk, "\x00\x11\x00\x11\x00\x11\x00\x11\x00\x11\x00\x11\x00\x11\x00\x11", 16);
          break;
      default:                 //No parameters
          ret = 0;
          break;
    }
    return ret;
}

static sndLED(void) {
    uint8 cmd[320];
    pcdRxResult_t rsp;
    int16 len = 0;

    memset(cmd, 0, sizeof(cmd));
    cmd[0] = CL_LED;
    cmd[2] = 0x04;
    cmd[4] = 0x02;
    cmd[5] = 0x03;
    len = 8;
    //switch on
    pcdProcessApdu(pcdHandle, len, cmd, (void *) &rsp, TRUE);
    psyTimerWakeAfter(50);
    //switch off
    cmd[4] = 0x01;
    pcdProcessApdu(pcdHandle, len, cmd, (void *) &rsp, TRUE);
    psyTimerWakeAfter(50);
    //switch on
    cmd[4] = 0x02;
    cmd[5] = 0x07;
    pcdProcessApdu(pcdHandle, len, cmd, (void *) &rsp, TRUE);
    return;
}

static sndBUZ(void) {
    uint8 cmd[320];
    pcdRxResult_t rsp;
    int16 len = 0;

    memset(cmd, 0, sizeof(cmd));
    cmd[0] = CL_BUZ;
    cmd[2] = 0x06;
    cmd[4] = 0x02;
    cmd[5] = 0x04;              //deviseur de la frequence
    cmd[6] = 0x1F;              //duree de activation
    cmd[8] = 0x80;              //duree de periode
    len = 10;
    //switch on
    pcdProcessApdu(pcdHandle, len, cmd, (void *) &rsp, TRUE);
    psyTimerWakeAfter(100);
    //switch off
    cmd[4] = 0x01;
    pcdProcessApdu(pcdHandle, len, cmd, (void *) &rsp, TRUE);
    psyTimerWakeAfter(50);
    return;
}

static sndSCN(void) {
    uint8 cmd[1060];
    pcdRxResult_t rsp;
    int16 len = 0, ImgLen = 0, SaveLen = 0;
    int16 i;
    static ImgNo = 0;
    int16 ofs = 0, iter = 0;

    memset(cmd, 0, sizeof(cmd));

    switch (ImgNo) {
      case 0:
          ImgLen = sizeof(img1);
          if(ImgLen > 128) {
              ofs = ImgLen - 128;
              ImgLen = 128;
          }
          break;
      case 1:
          ImgLen = sizeof(ingenico);
          if(ImgLen > 128) {
              ofs = ImgLen - 128;
              ImgLen = 128;
          }

          break;
      default:
          ImgLen = sizeof(img2);
          if(ImgLen > 128) {
              ofs = ImgLen - 128;
              ImgLen = 128;
          }

          break;
    }
    SaveLen = ImgLen + ofs;
    while(32) {
        len = ImgLen;

        cmd[0] = CL_SCN;
        cmd[1] = 0x00;          //premiere trame
        cmd[2] = len % 0x0100;  //length LByte
        cmd[3] = len / 0x0100;  //length HByte
        cmd[4] = iter;          //premiere ligne
        cmd[5] = 0x01;          //premiere colonne
        cmd[6] = 0x07;          //derniere ligne
        cmd[7] = 0x01;          //Nb de colonnes
        cmd[8] = 0x01;          //type
        cmd[9] = 0x02;          //bitmap
        cmd[10] = 0x00;

        i = 0;
        while(len) {
            if(ImgNo == 0)
                cmd[12 + i] = img1[i + (SaveLen - ofs) - len];
            if(ImgNo == 1)
                cmd[12 + i] = ingenico[i + (SaveLen - ofs) - len];
            if((ImgNo != 0) && (ImgNo != 1))
                cmd[12 + i] = img2[i + (SaveLen - ofs) - len];
            len--;
            i++;
        }

        len = ImgLen + 12;
        //show
        pcdProcessApdu(pcdHandle, len, cmd, (void *) &rsp, TRUE);
        if(ofs == 0)
            break;
        ImgLen = ofs;
        if(ofs) {
            if(ofs > 128)
                len = 128;
            else
                len = ofs;
            ofs = ImgLen - len;
            ImgLen = len;
            iter++;
        }
    }
    ImgNo++;
    return;
}

static int16 SendCmd(unsigned short cmdId) {
    int16 ret, idx;
    uint8 cmd[320];
    pcdRxResult_t rsp;
    int16 len = 0;
    uint8 debug[30];

    memset(cmd, 0, sizeof(cmd));

    if(cmdId == CL_LED)
        return sndLED();
    if(cmdId == CL_BUZ)
        return sndBUZ();
    if(cmdId == CL_SCN)
        return sndSCN();

    memcpy((void *) cmd, (void *) cmdHdr, Len_cdmHdr);
    memcpy((void *) &cmd[Len_cdmHdr], (void *) cmdStr, Len_cdmStr);

    cmd[12] = 0x02;
    cmd[16] = H_BYTE(cmdId);
    cmd[17] = L_BYTE(cmdId);

    ret = buildPrm(&cmd[20], cmdId);
    len = ret + Len_cdmStr;
    cmd[4] = len % 0x0100;
    cmd[5] = len / 0x0100;
    len = len + Len_cdmHdr;

    ret = pcdProcessApdu(pcdHandle, len, cmd, (void *) &rsp, 0x02);

    if(ret < RET_OK) {
        sprintf((char *) debug, "ERROR CMD = 0x%X", ret);
        tcikPrint((char *) debug);
        return ret;
    }
    ret = rsp.Data[rsp.Length - 1];
    sprintf((char *) debug, "CMD Rsp = 0x%X", ret);
    tcikPrint((char *) debug);

    switch (cmdId) {
      case MF_Read:
      case MF_Value:
          for (idx = 3; idx >= 0; idx--) {
              sprintf(debug, "0x%02X 0x%02X 0x%02X 0x%02X",
                      rsp.Data[rsp.Length - (idx * 4) - 3 - 10]
                      , rsp.Data[rsp.Length - (idx * 4) - 2 - 10]
                      , rsp.Data[rsp.Length - (idx * 4) - 1 - 10]
                      , rsp.Data[rsp.Length - (idx * 4) - 10]);
              tcikPrint(debug);
          }
          break;
      default:
          break;
    }
    return ret;
}

void tcik0157(void) {
    int16 ret;

    hmiOpen("DEFAULT", &displayHandle);
    hmiADDisplayText(displayHandle, 0, 0, " tcik0157");
    hmiADDisplayText(displayHandle, 1, 0, "TP+ CLess");
    tcikPrint("tcik0157");
    tcikPrint("----------");

    // assign the contactless reader
    ret = pcdCOMSetReader("COM1", 0x51);
    if(ret != RET_OK)
        goto lblKO;

    // Open Contactless peripheral
    ret = pcdOpen("COM1", &pcdHandle);
    if(ret != RET_OK)
        goto lblKO;
    tcikPrint("CLESS COM1 OPEN");
    hmiADDisplayText(displayHandle, 2, 0, " CLESS OPEN OK... ");

    tcikPrint("CL_LED");
    ret = SendCmd(CL_LED);

//    tcikPrint ("CL_BUZ");
//  ret = SendCmd(CL_BUZ);
//   
//  tcikPrint ("CL_BUZ");
//  ret = SendCmd(CL_BUZ);
//       
//  tcikPrint ("CL_BUZ");
//  ret = SendCmd(CL_BUZ);

    tcikPrint("CL_SCN");
    ret = SendCmd(CL_SCN);

    tcikPrint("CL_SCN");
    ret = SendCmd(CL_SCN);

    tcikPrint("CL_SCN");
    ret = SendCmd(CL_SCN);

    goto lblKO;

/*
    tcikPrint ("IDLE SCREEN");
    psyTimerWakeAfter(500);
    ret = SendCmd(CL_MsgDsp);
    if (ret < RET_OK)
        goto lblKO;
*/

    psyTimerWakeAfter(500);
    tcikPrint("OPEN MF");
    ret = SendCmd(MF_Open);
    if(ret < RET_OK)
        goto lblKO;

    psyTimerWakeAfter(500);
    tcikPrint("CHECK MF");
    ret = SendCmd(MF_Check);
    if(ret < RET_OK)
        goto lblKO;
    if(ret == 0) {              //Open Mifare Interface, if not opened yet
        psyTimerWakeAfter(100);
        tcikPrint("OPEN MF");
        ret = SendCmd(MF_Open);
        if(ret < RET_OK)
            goto lblKO;
    }

    tcikPrint("DETECT MF");
    ret = SendCmd(MF_Detect);
    if(ret < RET_OK)
        goto lblKO;
    //if (ret != 1) // card is not detected
    //  goto lblKO;

    tcikPrint("CL_LED");
    psyTimerWakeAfter(500);
    ret = SendCmd(CL_LED);
    if(ret < RET_OK)
        goto lblKO;

    psyTimerWakeAfter(200);
    tcikPrint("ACTIVE CARD");
    ret = SendCmd(MF_Activate);
    if(ret < RET_OK)
        goto lblKO;
    if(ret != 0)                // card is not activated
        goto lblKO;

    Sector = 1;

    tcikPrint("AUTHENTICATE");
    ret = SendCmd(MF_Auth);
    if(ret < RET_OK)
        goto lblKO;
    if(ret != 0)                // card is not authenticated
        goto lblKO;

    Sector = 1;
    Block = 3;

    tcikPrint("READ TRAILER DATA");
    ret = SendCmd(MF_Read);
    if(ret < RET_OK)
        goto lblKO;
    if(ret != 0)                // card is not authenticated
        goto lblKO;

    tcikPrint("WRITE TRAILER DATA");

    ret = SendCmd(MF_Write);
    if(ret < RET_OK)
        goto lblKO;
    if(ret != 0)                // card is not authenticated
        goto lblKO;

    tcikPrint("READ TRAILER DATA");
    ret = SendCmd(MF_Read);
    if(ret < RET_OK)
        goto lblKO;
    if(ret != 0)                // card is not authenticated
        goto lblKO;

    tcikPrint("CLOSE MF");
    ret = SendCmd(MF_Close);

    hmiADDisplayText(displayHandle, 3, 0, "TEST OK :-)");
    goto lblEnd;
  lblKO:
    hmiADDisplayText(displayHandle, 0, 0, "TEST KO :-(");
    tcikPrint("CLOSE MF");
    ret = SendCmd(MF_Close);

  lblEnd:
    //ret = SendCmd(CL_Init);
    pcdClose(pcdHandle);
    pcdCOMClose(pcdHandle);
    hmiADDisplayText(displayHandle, 0, 0, " tcik0156 end");
    hmiClose(displayHandle);
}
