#ifndef __KEY_H

//This file is automatically generated from "dbs.xml" file
//Don't modify it manually!
//It is to be included into "str.h"

/** \defgroup strgroup STR Structure components
 *
 * The most of structure components are generated automatically from dbs.xml file
 * These files are:
 *  - KEY.H: header file containing the keys to access data elements and automatically generated functions declarations
 *  - MAP.H: header file containing internal functions and structures declarations
 *  - DFT.H: header file containing default values to initialize data elements
 *  - STR.H: All structure component declarations that are not generated automatically
 *  - MAP.C: Data access functions and descriptor constructors
 *  - DFT.C: Data base reset functions
 *  - RPT.C: receipt layout
 *  - SCN.C: graphical scenes descriptors
 *  - SCR.C: screen processing functions
 *  - STR.C: functions that are not generated autiomatically
 * @{
*/
/** Dimension macro, the number of elements between sentinels
 * \param BEG Starting sentinel
 * \param END Ending sentinel
 * \header str\\key.h
 *
 * The macro is used calculate a dimension of a data structure:
 *  - number of fields in a record
 *  - number of rows in a table
 *  - etc
 */
#define DIM(BEG,END) ((END)-(BEG)-1)

enum eLen{ ///<Field Lengths
    lenBeg, ///<start sentinel
    lenCmpDat=16,
    lenCmpTim=8,
    lenDatTim=14,
    lenMnu=(2+dspW),
    lenTrk2=40,
    lenPan=19,
    lenExpDat=4,
    lenAmt=12,
    lenChn=16,
    lenPabx=4,
    lenPrefix=4,
    lenPhone=16,
    lenPwd=4,
    lenEnd ///<end sentinel
};

/** The key enum is used to access data elements using the functions mapGet() and mapPut().
 * It contains all the data elements saved in volatile and non-volatile memory.
 * These data elements can be organized in tables, records or multirecords.
 * The calculated data elements are described using converters and combos.
 * Index and and key arrays can be also accessed using keys in key enum.
 */
enum eKey{ ///<access keys to all the data in the database
    keyBeg, ///<start sentinel
        appBeg, ///<application parameters record
            appCmpDat, ///<compile date
            appCmpTim, ///<compile time
            appChn, ///<Communication channel settings
            appPabx, ///<Phone PABX
            appPrefix, ///<Phone Prefix
            appPhone, ///<Authorisation server phone number
            appMrcPwd, ///<Merchant password
            appAdmPwd, ///<Administrator password
            appExp, ///<Currency exponent
        appEnd,
        mnuBeg, ///<menu tree
            mnuMainMenu, 
            mnuCustomer, 
            mnuMerchant, 
            mnuAdmin, 
            mnuTest, 
            mnuTestReq, 
        mnuEnd,
        msgBeg, ///<screen messages
            msgSpaces, 
            msgAreYouSure, 
            msgMemoryReset, 
            msgProcessingError, 
            msgWrongPin, 
            msgPwdInput, 
            msgDialing, 
            msgWait, 
            msgSend, 
            msgReceive, 
            msgEnterAmount, 
            msgEnterCard, 
            msgEmpty, 
        msgEnd,
        rptBeg, ///<receipt formatting strings
            rptSpaces, 
            rptEmpty, 
        rptEnd,
        scrBeg, ///<user screen structure
            scrCmd, ///<command 'b'(beep)|'s'(show)|'i'(ignore)
            scrMsg0, ///<to be displayed on 1st line
            scrMsg1, ///<to be displayed on 2nd line
            scrMsg2, ///<to be displayed on 3rd line
            scrMsg3, ///<to be displayed on 4th line
            scrDly, ///<waiting delay
        scrEnd,
        regBeg, ///<registry record
            regTrxNo, ///<transaction number
        regEnd,
        traBeg, ///<transaction related data situated in volatile memory
            traDatTim, ///<current date and time CCYYMMDDhhmmss
            traMnuItm, ///<current menu item selected
            traCtx, ///<context message
            traEntMod, ///<card entry mode
            traTrk2, ///<track 2 of the card
            traPan, ///<card number
            traExpDat, ///<expiry date
            traAmt, ///<transaction amount
        traEnd,
    keyEnd ///<end sentinel
};

enum eInf{
    infBeg, ///<start sentinel
    infConfirmReset,
    infProcessingError,
    infWrongPin,
    infPwdInput,
    infDialing,
    infSendReq,
    infRecvRsp,
    infAmtInput,
    infCardInput,
    infEnd ///<end sentinel
};


/** \weakgroup mapgroup MAP
MAP component contains functions generated automatically.
* They are used by logical components
* to manipulate with data elements
* @{
*/
int mapInit(void); ///<initialise data base descriptors
int mapReset(word key); ///<reset non-volatile tables and records (all if key keyBeg)
int mapMove(word key,word idx); ///<move cursor for subspace containing key to row idx
int mapCache(int key); ///<enable/disable cache
int mapLoad(word key); ///<load a cache buffer from DFS section / load an index into RAM
int mapSave(word key); ///<save a cache buffer into DFS section / save index into file
int mapFlush(word key); ///<flush cache buffer into DFS section
int mapIns(word key); ///<insert an row into an index
int mapDel(word key); ///<delete a row from an index
int mapFind(word key,const char *pat,word beg,word end);
 ///<perform a search operation in a multirecord
int mapExport(word key,byte sec); ///<export a data element into a DFS section
int mapGet(word key,void *ptr,word len); ///<retrieve data element
int mapPut(word key,const void *ptr,word len); ///<save data element
/** @} */
/** \name Shortcut macros
* The macros provide shortcuts to call map functions
* to reduce the number of arguments
* @{
*/
#define mapGetByte(KEY,DST) mapGet(KEY,&DST,sizeof(byte))
#define mapPutByte(KEY,SRC) mapPut(KEY,bPtr(SRC),sizeof(byte))
#define mapGetWord(KEY,DST) mapGet(KEY,&DST,sizeof(word))
#define mapPutWord(KEY,SRC) mapPut(KEY,wPtr(SRC),sizeof(word))
#define mapGetCard(KEY,DST) mapGet(KEY,&DST,sizeof(card))
#define mapPutCard(KEY,SRC) mapPut(KEY,cPtr(SRC),sizeof(card))
//#define mapGetStr(KEY,DST) not to be used, it is risky!
#define mapPutStr(KEY,SRC) mapPut(KEY,SRC,0)
/** @} */

/** \weakgroup dftgroup DFT
* DFT component contains functions are generated automatically.
* They are used to fill the data base by default values.
* The functions getCmpDat() and getCmpTim() are used to detect
* the data base initialisation condition.
* @{
*/
const char *getCmpDat(void); ///<return compile date of the file dft.c
const char *getCmpTim(void); ///<return compile time of the file dft.c
int dftReset(word key); ///<fill application data base by default values
/** @} */

#define __KEY_H
#endif

/** @} */
