#include "log.h"

/*******************************************************************************
 * Message.c
 *------------------------------------------------------------------------------
 * This file was automatically generated by INGEDEV and must be filled out
 * by the developer.
 ******************************************************************************/
#include "string.h"
#include "unicapt.h"
#include "message.h"
#include "gmaDefines.h"
#include "GmaMsg.h"
#include "gmaMsgCon.h"
#include "gmaPgMsg.h"

static void treatPowerOn(amgMsg_t *msgReceive);
static void treatIntegrityCheck(amgMsg_t *msgReceive);
static void treatStartup(amgMsg_t *msgReceive);
static void treatTransaction(amgMsg_t *msgReceive);
static void treatTransactionQuery(amgMsg_t *msgReceive);
static void treatEventOccur(amgMsg_t *msgReceive);
static void treatEventSMF(amgMsg_t *msgReceive);
static void treatPowerLevel(amgMsg_t *msgReceive);


typedef struct{
   uint16 msgType;
   void (*func)(amgMsg_t *msgReceive);
}treatMsgStruct_t;

/**
 * Treat received messages from the GMA
 */
void treatRecMsg(amgMsg_t *msgReceive)
{
   uint16 i;
   amgMsg_t answerMessage;

   /**
    * vector with the treated message types. Add more
    * message types if needed.
    */
   treatMsgStruct_t treatMsg[] = 
   {
      {MSG_POWER_ON,                 treatPowerOn},
      {GMA_MSG_POWER_ON,             treatPowerOn},
      {GMA_MSG_INIT_INTEGRITY_CHECK, treatIntegrityCheck},
      {GMA_MSG_STARTUP,              treatStartup},
      {GMA_MSG_TRANSACTION,          treatTransaction},
      {GMA_MSG_TRANSACTION_QUERY,    treatTransactionQuery},
      {GMA_MSG_EVENT_OCCUR,          treatEventOccur},
      {GMA_MSG_MNT,                  treatEventSMF},
      {GMA_MSG_POWER_LEVEL,          treatPowerLevel},
      {0, 0}
   };
   
   /** 
    *  prepare the enconding of the answer message
    */
   gmaMsgEncode(&answerMessage, msgReceive->msgType);
   
   for(i=0; treatMsg[i].func != NULL; i++)
   {
      if(msgReceive->msgType == treatMsg[i].msgType)
      {
         hdlBefore(); //GMA-UTA interface
         treatMsg[i].func(msgReceive);
         hdlAfter(); //GMA-UTA interface
      }
   }
   /**
    * End the encoding process of the answer message
    */
   gmaMsgEndEncode();
   
   /**
    * The message is sent here. Even if there is no function in the treatMsg
    * to treat a specific message an answer will be send to the GMA. If not
    * the GMA would block.
    */
   amgSendId(msgReceive->callerTaskId, &answerMessage);
}


/**
 * Treat the power on message
 */
static void treatPowerOn(amgMsg_t *msgReceive)
{
   //Initialize the functions to talk with plugins
   gmaPgMsgInitialize(msgReceive);
   
   /**
    * Prepare the answer to the power on.
    * The gmaMsgEncode was already called in the treatRecMsg function
    */
   
   // Add the physical Application info
   gmaMsgAddPhysicalAppInfo(RET_OK, 0x101, __IDLEAPP__, GMA_USER_APPLICATION);
   // TODO Uncomment to add a logical application.
   //   gmaMsgAddLogicalAppInfo(1, "logicalApp1");
   
    hdlPowerOn(); //GMA-UTA interface

   // TODO Uncomment if the application can process EMV cards.
   //   gmaMsgEmvAid(..., ...);
   
   // Tell the GMA to display our menu.
   // TODO Remove the next 2 lines if you want to manage the menu yourself.
   //amgSetLanguage(LANGUAGE_EN);
   //gmaCstMsgResourceMenuStatus(0xFF, 1);
}

/**
 * Treat the integrity check message
 */
static void treatIntegrityCheck(amgMsg_t *msgReceive)
{
   // tell that all logical applications are OK
   gmaMsgAddLogicalAppStatus(0xFF,0);
}

/**
 * treat the startup message.
 * Last initialization message. After the GMA send this message to all
 * application the GMA will display its initial screen and wait for user 
 * interactions.
 */
static void treatStartup(amgMsg_t *msgReceive)
{
    //GMA-UTA interface: BEG
    uint16 len;
    uint32 date, time;

    psyDateTimeGet(&date, &time);
    gmaMsgScheduleEvent(0,GMA_EVENT_ACTION_ADD,1,date,time); //schedule an immediate wakeup 
    len= strlen(__IDLEMSG__);
    gmaMsgMediaData(0,1,GMA_MEDIA_TEXT,(uint16)(len+1),(uchar *)__IDLEMSG__); //provide idle screen message
    //GMA-UTA interface: END
}

/**
 * Treat the event occur message. Message received when an schedule
 * event occurs
 */
static void treatEventOccur(amgMsg_t *msgReceive)
{
    //GMA-UTA interface: BEG
   uint16 len;
   gmaStructHeader_t *hdr;
   gmaStructEventOccur_t *evt;
   uint32 date, time;
   int ret;
   
   gmaMsgDecode(msgReceive);
   
   if(gmaMsgRead((void **)&hdr, &len) != RET_OK ||
      hdr->id != GMA_STRUCT_EVENT_OCCUR)
   {
      gmaMsgEndDecode();
      return;
   }
   gmaMsgEndDecode();
      
   evt= (gmaStructEventOccur_t *)hdr;
   psyDateTimeGet(&date, &time);
   ret= hdlTimer(evt->eventId,&date,&time);
   if(ret) gmaMsgScheduleEvent(0,GMA_EVENT_ACTION_ADD,1,date,time);
    //GMA-UTA interface: END
}

/**
 * treat the SMF (maintenance) message
 */
static void treatEventSMF(amgMsg_t *msgReceive)
{
}

/**
 * treat the power level message. This message was sent by the POR plugin
 * in terminal with battery.
 */
static void treatPowerLevel(amgMsg_t *msgReceive)
{
}

//GMA-UTA interface BEG
static void getTrk(char *trk,gmaStructTransMagTrack_t *mag){ //convert magstripe read to ASCII format
    int idx,ofs;
    if(mag->trackNumber==0) return; //normally, it is impossible
    if(mag->trackNumber>3) return; //normally, it is impossible
    if(mag->trackLength>128) return; //normally, it is impossible
    ofs= 128*(mag->trackNumber-1);
    memcpy(trk+ofs,mag->magTrack,mag->trackLength);
    for(idx= 0; idx<mag->trackLength; idx++){
    	switch(mag->trackNumber){
	      case 1: trk[ofs+idx]+= 0x20; break;
	      case 2: trk[ofs+idx]|= 0x30; break;
	      case 3: trk[ofs+idx]+= 0x30; break;
	      default: break;
	    }
    }
}
//GMA-UTA interface END

/**
 * Treat the transaction message
 */
static void treatTransaction(amgMsg_t *msgReceive)
{
   uint16 length;
   gmaStructHeader_t *header;
   gmaStructTransType_t *transType;
   
   gmaMsgDecode(msgReceive);
   
   if(gmaMsgRead((void **)&header, &length) != RET_OK ||
      header->id != GMA_STRUCT_TRANS_TYPE)
   {
      gmaMsgEndDecode();
      return;
   }
      
   transType = (gmaStructTransType_t *) header;
   
   switch(transType->transType)
   {
      case GMA_TRANS_KEY_PRESSED:
      // Query acceptance level for a key pressed.
      // This event is sent when a key is pressed that has an associated action "GMA_KEY_ACTION_DEFAULT".
      // In the default implementation of the custom part, no key is configured to
      // trigger this event.
      {
         gmaStructTransKeyPressed_t *keyPressed;
         if(gmaMsgRead((void **)&keyPressed, &length) != RET_OK ||
            keyPressed->header.id != GMA_STRUCT_TRANS_KEY_PRESSED)
         {
            break;
         }
         //TODO: Put the code to treat the key pressed event here
         //TODO: Check to what logical ID the event is refered
      }
      break;
      
      case GMA_TRANS_MAG_CARD:
      // The application has been selected to process the magnetic card.
      {
         gmaStructTransMagCard_t *magCard;
         gmaStructTransMagTrack_t *magTrack;
         //GMA-UTA interface BEG
         char trk[128*3];
         memset(trk,0,128*3);
         //GMA-UTA interface END
         if(gmaMsgRead((void **)&magCard, &length) != RET_OK ||
            magCard->header.id != GMA_STRUCT_TRANS_MAG_CARD)
         {
            break;
         }
         while(gmaMsgRead((void **)&magTrack, &length) == RET_OK)
         {
            if(magTrack->header.id == GMA_STRUCT_TRANS_MAG_TRACK)
            {
             getTrk((char *)trk,magTrack); //GMA-UTA interface 
            }
         }
         //TODO: Put the code to treat the mag card event here
         //TODO: Check to what logical ID the event is refered
         hdlMagStripe((char *)trk); //GMA-UTA interface
      }
      break;
      
      case GMA_TRANS_MENU:
      // An item of the application's menu has been selected.
      {
         gmaStructTransMenu_t *transMenu;
         if(gmaMsgRead((void **)&transMenu, &length) != RET_OK ||
            transMenu->header.id != GMA_STRUCT_TRANS_MENU)
         {
            break;
         }
         hdlMainMenu(); //GMA-UTA interface
      }
      break;
      
      case GMA_TRANS_SMART_CARD:
      // The application has been selected to process the smart card.
      {
         gmaStructTransSmartCard_t *transSmartCard;
         //byte buf[__FSBUFLEN__];
         if(gmaMsgRead((void **)&transSmartCard, &length) != RET_OK ||
            transSmartCard->header.id != GMA_STRUCT_TRANS_SMART_CARD)
         {
            break;
         }
         //TODO: Put the code to treat the smart card event here
         //TODO: Check to what logical ID the event is refered
         //GMA-UTA interface BEG
        while(gmaMsgRead((void **)&header,&length)==RET_OK){
            if(header->id==GMA_STRUCT_TRANS_SMC_EMV){
                //gmaStructTransSmcEmv_t *emv= (gmaStructTransSmcEmv_t *)header;
                //memset(buf,0,__FSBUFLEN__);
                //if(emv->responseLength>__FSBUFLEN__) continue; //impossible
                //memcpy(buf,emv->response,emv->responseLength);
            }
        }
        //hdlSmartCard(buf); //uncomment it for EMV applications
         //GMA-UTA interface END
      }
      break;
      
      case GMA_TRANS_ADM_FUNC:
      // Ask for an administrative function.
      // Not implemented in the default implementation of the custom part.
      {
         gmaStructTransAdmFunc_t *admFunc;
         if(gmaMsgRead((void **)&admFunc, &length) != RET_OK ||
            admFunc->header.id != GMA_STRUCT_TRANS_ADM_FUNC)
         {
            break;
         }
         // TODO Put the code to treat the Adm function event here
         // TODO Check to what logical ID the event is refered
      }
      break;
      
      // TODO Put more transaction types if necessary
      default:
      break;
   }
   
   gmaMsgEndDecode();
}

/**
 * Treat the transaction query message.
 */
static void treatTransactionQuery(amgMsg_t *msgReceive)
{
   uint16 length;
   gmaStructHeader_t *header;
   gmaStructTransType_t *transType;
   
   gmaMsgDecode(msgReceive);
   
   if(gmaMsgRead((void **)&header, &length) != RET_OK ||
      header->id != GMA_STRUCT_TRANS_TYPE)
   {
      gmaMsgEndDecode();
      return;
   }
   
   transType = (gmaStructTransType_t *) header;
   
   switch(transType->transType)
   {
      case GMA_TRANS_KEY_PRESSED:
      // Query acceptance level for a key pressed.
      // This event is sent when a key is pressed that has an associated action "GMA_KEY_ACTION_DEFAULT".
      // In the default implementation of the custom part, no key is configured to
      // trigger this event.
      {
         gmaStructTransKeyPressed_t *keyPressed;
         if(gmaMsgRead((void **)&keyPressed, &length) != RET_OK ||
           keyPressed->header.id != GMA_STRUCT_TRANS_KEY_PRESSED)
         {
            break;
         }
         // TODO  Put the code to decide the accept level
         //accept level of all logical applications
         gmaMsgAddQueryResult(0xFF, GMA_ACCEPTLEVEL_MEDIUM);

         // TODO You can add here the accept level of each logical application declared
         // TODO gmaMsgAddQueryResult(1, GMA_ACCEPTLEVEL_MEDIUM);
      }
      break;
      
      case GMA_TRANS_MAG_CARD:
      // Query acceptance level for a magnetic card.
      {
         gmaStructTransMagCard_t *magCard;
         gmaStructTransMagTrack_t *magTrack;
         //GMA-UTA interface BEG
         int ret;
         byte trk[128*3];
         memset(trk,0,128*3);
         //GMA-UTA interface END
         if(gmaMsgRead((void **)&magCard, &length) != RET_OK ||
            magCard->header.id != GMA_STRUCT_TRANS_MAG_CARD)
         {
            break;
         }
         while(gmaMsgRead((void **)&magTrack, &length) == RET_OK)
         {
            if(magTrack->header.id == GMA_STRUCT_TRANS_MAG_TRACK)
            {
             getTrk((char *)trk,magTrack); //GMA-UTA interface 
            }
         }
         //TODO: Put the code to treat the mag card event here
         //TODO: Check to what logical ID the event is refered
         //GMA-UTA interface BEG
         ret= hdlAskMagStripe((char *)trk);
         gmaMsgAddQueryResult(0xFF,(uint8)((ret>0)?GMA_ACCEPTLEVEL_MEDIUM:GMA_ACCEPTLEVEL_NO_ACCEPT));
         //GMA-UTA interface END
      }
      break;
      case GMA_TRANS_MENU:
      {
         gmaStructTransMenu_t *transMenu;
         if(gmaMsgRead((void **)&transMenu, &length) != RET_OK ||
            transMenu->header.id != GMA_STRUCT_TRANS_MENU)
         {
            break;
         }

         //TODO: Put the code to decide the accept level
         //accept level of all logical applications
         gmaMsgAddQueryResult(0xFF, GMA_ACCEPTLEVEL_MEDIUM);

         // TODO You can add here the accept level of each logical application declared
         // TODO gmaMsgAddQueryResult(1, GMA_ACCEPTLEVEL_MEDIUM);
      }
      break;
      
      case GMA_TRANS_SMART_CARD:
      // Query acceptance level for a non-EMV card.
      // Not supported in GMA 1.71.
      {
         gmaStructTransSmartCard_t *transSmartCard;
         if(gmaMsgRead((void **)&transSmartCard, &length) != RET_OK ||
            transSmartCard->header.id != GMA_STRUCT_TRANS_SMART_CARD)
         {
            break;
         }
         // TODO Put the code to decide the accept level
         //accept level of all logical applications
         gmaMsgAddQueryResult(0xFF, GMA_ACCEPTLEVEL_MEDIUM);

         // TODO You can add here the accept level of each logical application declared
         // TODO gmaMsgAddQueryResult(1, GMA_ACCEPTLEVEL_MEDIUM);
      }
      break;
      
      case GMA_TRANS_ADM_FUNC:
      // Query acceptance level for an administrative function.
      // Not implemented in the default implementation of the custom part.
      {
         gmaStructTransAdmFunc_t *admFunc;
         if(gmaMsgRead((void **)&admFunc, &length) != RET_OK ||
            admFunc->header.id != GMA_STRUCT_TRANS_ADM_FUNC)
         {
            break;
         }
         // TODO Put the code to decide the accept level
         // accept level of all logical applications
         gmaMsgAddQueryResult(0xFF, GMA_ACCEPTLEVEL_MEDIUM);

         // TODO You can add here the accept level of each logical application declared
         // TODO gmaMsgAddQueryResult(1, GMA_ACCEPTLEVEL_MEDIUM);
      }
      break;
      // TODO Put more transaction types if necessary
   }
   
   gmaMsgEndDecode();
}
