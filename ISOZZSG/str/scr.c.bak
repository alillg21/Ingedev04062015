//Subversion reference
//$HeadURL: https://svn.ingenico.com/UTAPROJECTS/sea-partner/5W/trunk/ISO5WPH/str/scr.c $
//$Id: scr.c 1784 2009-03-31 12:16:05Z ajloreto $

#include <string.h>
#include "str.h"

static int getScr(word key, tInfo * dst, word len) {
    int ret;
    byte idx;
    word fld;
    word msg;

    VERIFY(dst);
    VERIFY(len == sizeof(*dst));

    memset(dst, 0, sizeof(tInfo));

    ret = mapMove(scrBeg, key);
    CHECK(ret == key, lblKO);

    ret = mapLoad(scrBeg);      //load it into the cache buffer
    CHECK(ret >= 0, lblKO);

    MAPGETBYTE(scrCmd, dst->cmd, lblKO);

    if(dst->cmd == 'i')
        goto lblEnd;            //ignore user screen

    fld = scrMsg0;
    for (idx = 0; idx < dspH; idx++) {
        MAPGETWORD(fld++, msg, lblKO);
        MAPGET(msg, dst->msg[idx], lblKO);
    }

    MAPGETBYTE(scrDly, dst->dly, lblKO);

    ret = sizeof(*dst);
    goto lblEnd;
  lblKO:
    ret = -1;
  lblEnd:
    return ret;
}

static byte logoMaestro[] = {

    0xFF, 0xFF, 0x80, 0x07, 0x80, 0x53, 0x81, 0xFF, 0x83, 0xFF, 0x87, 0xFF,
    0x87, 0xFF, 0x9F, 0xFF,
    0xBF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0xFF, 0x33, 0xFE, 0xB3, 0xFE, 0xAA,
    0xFE, 0xAB, 0xFE, 0x96,

    0xFF, 0xFF, 0x80, 0x07, 0xF8, 0x38, 0xFC, 0x40, 0xFF, 0x80, 0xFE, 0x00,
    0xFF, 0xC0, 0xFC, 0x00,
    0xFF, 0xE0, 0xF8, 0x00, 0xFF, 0xF0, 0xF0, 0x00, 0xFF, 0xF0, 0x18, 0xEE,
    0xD7, 0x87, 0x10, 0x7E,

    0xFF, 0xFE, 0xFC, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x20, 0x00, 0x10,
    0x00, 0x08, 0x00, 0x04,
    0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x20, 0x00, 0x40, 0x00, 0xEE, 0xE0,
    0x49, 0x90, 0x51, 0x10,

    0xFD, 0x95, 0xFD, 0xB4, 0xFF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0x9F, 0xFF,
    0x9F, 0xFF, 0x8F, 0xFF,
    0x87, 0xFF, 0x83, 0xFF, 0x80, 0xFF, 0x80, 0x3F, 0x80, 0x0F, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00,

    0xB7, 0xD2, 0x38, 0xEC, 0xFF, 0xF0, 0xF8, 0x00, 0xFF, 0xE0, 0xFC, 0x00,
    0xFF, 0xC0, 0xFF, 0x00,
    0xFF, 0x80, 0xFE, 0x80, 0xFC, 0x87, 0xF0, 0x18, 0xC0, 0x07, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00,

    0x91, 0x30, 0xD0, 0xE0, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x04,
    0x00, 0x04, 0x00, 0x08,
    0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x01, 0x80, 0xFE, 0x00, 0xFF, 0xFE,
    0x00, 0x00, 0x00, 0x00,

};

static byte logoCirrus[] = {
    0xFF, 0xFF, 0x80, 0x07, 0x80, 0x53, 0x81, 0xFF, 0x83, 0xFF, 0x87, 0xFF,
    0x87, 0xFF, 0x9F, 0xFF,
    0xBF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0xFF, 0xC3, 0xFF, 0x99, 0xFF, 0x3F,
    0xFF, 0x3F, 0xFF, 0x3F,

    0xFF, 0xFF, 0x80, 0x07, 0xF8, 0x38, 0xFC, 0x40, 0xFF, 0x80, 0xFE, 0x00,
    0xFF, 0xC0, 0xFC, 0x00,
    0xFF, 0xE0, 0xF8, 0x00, 0xFF, 0xF0, 0x90, 0x00, 0xFF, 0xF0, 0x98, 0x4D,
    0x99, 0xC1, 0x33, 0x93,

    0xFF, 0xFE, 0xFC, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x20, 0x00, 0x10,
    0x00, 0x08, 0x00, 0x04,
    0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xB7, 0xC0,
    0xB6, 0x00, 0xAC, 0xC0,

    0xFF, 0x39, 0xFF, 0x83, 0xFF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0x9F, 0xFF,
    0x9F, 0xFF, 0x8F, 0xFF,
    0x87, 0xFF, 0x83, 0xFF, 0x80, 0xFF, 0x80, 0x3F, 0x80, 0x0F, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00,

    0x33, 0x93, 0x33, 0x93, 0xFF, 0xF0, 0xF8, 0x00, 0xFF, 0xE0, 0xFC, 0x00,
    0xFF, 0xC0, 0xFF, 0x00,
    0xFF, 0x80, 0xFE, 0x80, 0xFC, 0x87, 0xF0, 0x18, 0xC0, 0x07, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00,

    0xE3, 0xC0, 0xE7, 0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x04,
    0x00, 0x04, 0x00, 0x08,
    0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x01, 0x80, 0xFE, 0x00, 0xFF, 0xFE,
    0x00, 0x00, 0x00, 0x00,

};

static byte logoVisa[] = {
    0xFF, 0xFF, 0x80, 0x00, 0xBF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF,
    0xBF, 0xFF, 0xBF, 0xFF,
    0xBF, 0xFF, 0x80, 0x00, 0x81, 0xC0, 0x81, 0xC1, 0x81, 0xC3, 0x81, 0xC7,
    0x81, 0xCF, 0x81, 0xDE,

    0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x00, 0x00, 0xDC, 0xFC, 0xDD, 0xFC, 0xDD, 0x80, 0xBB, 0x80,
    0x3B, 0xE0, 0x7B, 0xF1,

    0xFF, 0xFE, 0x00, 0x02, 0xFF, 0xFA, 0xFF, 0xFA, 0xFF, 0xFA, 0xFF, 0xFA,
    0xFF, 0xFA, 0xFF, 0xFA,
    0xFF, 0xFA, 0x00, 0x02, 0x3C, 0xE2, 0x3D, 0xF2, 0x7C, 0xE2, 0xEC, 0x02,
    0xCC, 0x02, 0xCC, 0x02,

    0x81, 0xFC, 0x81, 0xF8, 0x81, 0xF0, 0x81, 0xE0, 0x81, 0xC0, 0x80, 0x00,
    0xBF, 0xFF, 0xBF, 0xFF,
    0xBF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0x80, 0x00,
    0xFF, 0xFF, 0x00, 0x00,

    0x71, 0xF3, 0x70, 0x77, 0xEC, 0xEF, 0xEF, 0xEE, 0xEF, 0xDC, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
    0xFF, 0xFF, 0x00, 0x00,

    0xFC, 0x02, 0xFC, 0x02, 0xFC, 0x02, 0x1C, 0x02, 0x1C, 0x02, 0x00, 0x02,
    0xFF, 0xFA, 0xFF, 0xFA,
    0xFF, 0xFA, 0xFF, 0xFA, 0xFF, 0xFA, 0xFF, 0xFA, 0xFF, 0xFA, 0x00, 0x02,
    0xFF, 0xFE, 0x00, 0x00
};

static byte logoMC[] = {
    0x00, 0x00, 0xFF, 0xFF, 0x80, 0x07, 0x80, 0x7F, 0x81, 0xFF, 0x83, 0xFF,
    0x87, 0xFF, 0x87, 0xFF,
    0x9F, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xF6, 0xFF,
    0xF4, 0x89, 0xE4, 0xEB,

    0x00, 0x00, 0xFF, 0xFF, 0x80, 0x07, 0xF8, 0x38, 0xFC, 0x40, 0xFF, 0x80,
    0xFE, 0x00, 0xFF, 0xC0,
    0xFC, 0x00, 0xFF, 0xE0, 0xF8, 0x00, 0xFF, 0xF0, 0xF0, 0x00, 0xBF, 0xF7,
    0xB1, 0x5E, 0x15, 0x3C,

    0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x01, 0x03, 0x01, 0x00, 0xC1, 0x00, 0x21,
    0x00, 0x11, 0x00, 0x09,
    0x00, 0x05, 0x00, 0x05, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x19,
    0x75, 0x19, 0x16, 0x79,

    0xE0, 0x89, 0xEA, 0xAD, 0xCA, 0x89, 0xFF, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF,
    0x9F, 0xFF, 0x9F, 0xFF,
    0x8F, 0xFF, 0x87, 0xFF, 0x83, 0xFF, 0x80, 0xFF, 0x80, 0x3F, 0x80, 0x0F,
    0xFF, 0xFF, 0x00, 0x00,

    0xB1, 0x7C, 0xB7, 0x7E, 0x91, 0x77, 0xFF, 0xF0, 0xF8, 0x00, 0xFF, 0xE0,
    0xFC, 0x00, 0xFF, 0xC0,
    0xFF, 0x00, 0xFF, 0x80, 0xFE, 0x80, 0xFC, 0x60, 0xF0, 0x18, 0xC0, 0x07,
    0xFF, 0xFF, 0x00, 0x00,

    0x74, 0xD9, 0x54, 0xD9, 0x74, 0x69, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x05, 0x00, 0x05,
    0x00, 0x09, 0x00, 0x11, 0x00, 0x21, 0x00, 0x41, 0x01, 0x81, 0xFE, 0x01,
    0xFF, 0xFF, 0x00, 0x00
};

static byte logoJCB[] = {
    0x00, 0xff, 0x03, 0x80, 0x0e, 0x3f, 0x18, 0x40, 0x30, 0x9f, 0x61, 0x3f,
    0x61, 0x7f, 0xc1, 0x7f, 0xc1, 0x7f, 0xc1, 0x7c, 0xc1, 0x7c, 0xc1, 0x6c,
    0xc1, 0x64, 0xc1, 0x71, 0xc1, 0x7f, 0xc1, 0x7f,
    0xff, 0xff, 0x00, 0x00, 0xff, 0xfb, 0x10, 0x04, 0xc7, 0xf1, 0xcf, 0xf3,
    0xdf, 0xf7, 0xdf, 0xf7, 0xdf, 0xf7, 0xdc, 0x36, 0xd8, 0xf6, 0xd9, 0xf6,
    0xd8, 0xf6, 0xdc, 0x36, 0xdf, 0xf7, 0xdf, 0xf7,
    0xff, 0x00, 0x01, 0xc0, 0xfe, 0x70, 0x01, 0x18, 0xfd, 0x0c, 0xfd, 0x06,
    0xfd, 0x06, 0xfd, 0x03, 0xfd, 0x03, 0x0d, 0x03, 0x75, 0x03, 0x0d, 0x03,
    0x75, 0x03, 0x0d, 0x03, 0xfd, 0x03, 0xfd, 0x03,

    0xc1, 0x7f, 0xc1, 0x7f, 0xc2, 0x7f, 0xc4, 0xff, 0xc5, 0xfe, 0xc4, 0x01,
    0xc3, 0xfe, 0xc0, 0x00, 0xc0, 0x16, 0x60, 0x14, 0x60, 0x14, 0x30, 0x54,
    0x18, 0x76, 0x0e, 0x00, 0x03, 0x80, 0x00, 0xff,
    0xdf, 0xf7, 0xdf, 0xf7, 0x9f, 0xe7, 0x3f, 0xcf, 0x7f, 0x9f, 0x00, 0x40,
    0xff, 0xbf, 0x00, 0x00, 0xe0, 0x00, 0xa0, 0x00, 0xe3, 0x77, 0xa2, 0x55,
    0xe2, 0x76, 0x03, 0x55, 0x00, 0x00, 0xff, 0xff,
    0xfd, 0x03, 0xfd, 0x03, 0xfd, 0x03, 0xf9, 0x03, 0xf2, 0x03, 0x04, 0x03,
    0xf8, 0x03, 0x00, 0x03, 0x00, 0x03, 0x06, 0x06, 0x60, 0x06, 0x50, 0x0c,
    0x50, 0x18, 0x60, 0x70, 0x01, 0xc0, 0xff, 0x00,
};

static byte logoAmex[] = {
    0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f,
    0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x0a,
    0x00, 0x0b, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x08,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xab, 0x75, 0xba, 0x55,
    0xbb, 0x65, 0xaa, 0x55, 0xab, 0x55, 0x00, 0x00,
    0xff, 0xf8, 0xff, 0xf8, 0xff, 0xf8, 0xff, 0xf8, 0xff, 0xf8, 0xff, 0xf8,
    0xff, 0xf8, 0xff, 0xf8, 0xff, 0xf8, 0x00, 0x08, 0xdd, 0x28, 0x15, 0xa8,
    0x15, 0xe8, 0x1d, 0x68, 0xd5, 0x28, 0x00, 0x08,

    0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f,
    0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f,
    0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0x0f,
    0xff, 0xff, 0xe0, 0x00, 0xed, 0x5d, 0xe9, 0xd5, 0xed, 0xdd, 0xe9, 0xd1,
    0xed, 0x51, 0xe0, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xf8, 0x00, 0x08, 0xdb, 0x68, 0x52, 0x48, 0x9b, 0x68, 0x51, 0x28,
    0x5b, 0x68, 0x00, 0x08, 0xff, 0xf8, 0xff, 0xf8, 0xff, 0xf8, 0xff, 0xf8,
    0xff, 0xf8, 0xff, 0xf8, 0xff, 0xf8, 0xff, 0xf8,
};

static byte withLogo(word key) {
    switch (key) {
      //case infAmtInput:
      //case infTipInput:
     // case infConfirmPan:
      //case infTotal:
          return 1;
      default:
          break;
    }
    return 0;
}

static int scrLogo(word key) {
    int ret;
    const byte *ptr;
    byte row, col, logoidx;

    MAPGETBYTE(binLogoID, logoidx, lblKO);
    switch (logoidx) {
      case binLogoBeg:
          return 0;
      case binLogoVisa:
          ptr = logoVisa;
          break;
      case binLogoMC:
          ptr = logoMC;
          break;
      case binLogoJCB:
          ptr = logoJCB;
          break;
      case binLogoAmex:
          ptr = logoAmex;
          break;
      case binLogoCirrus:
          ptr = logoCirrus;
          break;
      case binLogoMaestro:
          ptr = logoMaestro;
          break;
      default:
          return 0;
    }
    for (row = 0; row < 2; row++) {
        for (col = 0; col < 3; col++) {
#ifndef _SIMULPC_
            ret = dspImg(col * 16, row * 16, 16, 16, ptr);
            //ret = dspImg(col * 32, row * 16, 32, 16, ptr);
            CHECK(ret >= 0, lblKO);
#endif
            ptr += 32;
        }
    }
    return 1;
  lblKO:return -1;
}

static int scrInfo(word key, byte dly) {
    int ret;
    tInfo inf;

    VERIFY(isSorted(infBeg, key, infEnd));
    VERIFY(key);

    trcS("scrInfo: Beg\n");
    ret = getScr((word) (key - 1), &inf, sizeof(inf));
    CHECK(ret == sizeof(inf), lblKO);

    if(dly < 0xFF)
        inf.dly = dly;
    if(withLogo(key)) {
        tInfo infDly;

        //Prepare dummy screen with dly only
        memset(&infDly, 0, sizeof(infDly));
        infDly.cmd = inf.cmd;
        infDly.dly = inf.dly;

        //Display text with zero delay
        inf.dly = 0;
        ret = info(&inf);
        CHECK(ret >= 0, lblKO);

        //Display logo with zero delay
        ret = scrLogo(key);
        CHECK(ret >= 0, lblKO);

        //Wait if needed
        ret = info(&infDly);
    } else {
        ret = info(&inf);
    }
    CHECK(ret >= 0, lblKO);

    goto lblEnd;
  lblKO:
    ret = -1;
  lblEnd:
    trcFN("scrInfo: ret=%d\n", ret);
    return ret;
}

static int bgdInfo(word key) {
    return scrInfo(key, 0);     //force zero delay
}

/** Retrieve user screen from database to display.
 * \return   Key pressed   
 * \param    key (I-) Data key.
 * \header log\\str.h
 * \source log\\scr.c 
 */ int usrInfo(word key) {
    return scrInfo(key, 0xFF);  //use delay from the data base
}

static int scrNumEntry(word key, card maxLen) {
    int ret = 0;
    word len;
    char buf[64 + 1];
    char fmt;
    card crdBuf;
    byte binBuf[64 + 1];
    byte binLen;

    VERIFY(isSorted(appBeg, key, appEnd) || isSorted(regBeg, key, regEnd)
           || isSorted(traBeg, key, traEnd));
    memset(buf, 0, sizeof(buf));

    fmt = mapDatFmt(key);
    CHECK(fmt > 0, lblKO);

    len = mapDatLen(key);
    CHECK(len > 0, lblKO);

    switch (fmt) {
      case 'B':
          MAPGET(key, buf, lblKO);
          binLen = buf[0];
          memcpy(binBuf, buf + 1, binLen);
          memset(buf, 0, sizeof(buf));
          ret = bin2hex(buf, binBuf, binLen);
          CHECK(ret > 0, lblKO);
          len = (len - 1) * 2;
          break;
      case 'N':
          len = maxLen;
          MAPGETCARD(key, crdBuf, lblKO);
          trcFN("crdBuf: %d\n", crdBuf);
          num2dec(buf, crdBuf, 0);
          break;
      case 'A':                //nothing to do
          MAPGET(key, buf, lblKO);
          break;
      default:
          goto lblKO;
    }

    ret = enterStr(3, buf, len + 1);
    CHECK(ret >= 0, lblKO);
    CHECK(ret == kbdVAL, lblEnd);

    CHECK(strlen(buf) <= len, lblKO);
    if (key != appPabx)				//no entry on pabx is allowed
    CHECK(strlen(buf) >= 1, lblKO);

    switch (fmt) {
      case 'B':
          len = strlen(buf);
          ret = hex2bin(binBuf, buf, 0);
          CHECK(ret >= 0, lblKO);
          memset(buf, 0, sizeof(buf));
          binLen = ret;
          buf[0] = binLen;
          memcpy(buf + 1, binBuf, binLen);
          len = binLen + 1;
          ret = mapPut(key, buf, len);
          break;
      case 'N':
          ret = dec2num(&crdBuf, buf, 0);
          trcFN("crdBuf: %d\n", crdBuf);
          MAPPUTCARD(key, crdBuf, lblKO);
          break;
      case 'A':                //nothing to do
          ret = mapPut(key, buf, len);
          break;
      default:
          goto lblKO;
    }
    CHECK(ret >= 0, lblKO);
    ret = kbdVAL;
    goto lblEnd;
  lblKO:
    ret = -1;
  lblEnd:
    trcFN("scrNumEntry: ret=%d\n", ret);
    return ret;
}

static int scrTcpIpEntry(word key) {
    int ret = 0;
    char buf[64 + 1];
    word len;

    memset(buf, 0, sizeof(buf));
    //len = mapDatLen(key);
    len = 15;                   //IP address, max of 15 characters including the dot(.)
    CHECK(len > 0, lblKO);

    MAPGET(key, buf, lblKO);
    ret = enterTcp(3, buf, len);
    if(ret == kbdVAL) {
        MAPPUTSTR(key, buf, lblKO);
        ret = kbdVAL;
    }
    goto lblEnd;
  lblKO:
    ret = -1;
  lblEnd:
    trcFN("scrTcpIpEntry: ret=%d\n", ret);
    return ret;
}

static int scrKeyEntry(word infKey, word key) {
    int ret = 0;
    byte val;
    byte savVal;
    char fmt;
    tInfo inf;

    trcS("scrKeyEntry: Beg\n");

    fmt = mapDatFmt(key);
    CHECK(fmt > 0, lblKO);
    CHECK(fmt == 'N', lblKO);

    ret = mapDatLen(key);
    CHECK(ret == 1, lblKO);     //One byte only

    MAPGETBYTE(key, savVal, lblKO);
    val = savVal;
    while(1) {
        ret = getScr((word) (infKey - 1), &inf, sizeof(inf));
        CHECK(ret == sizeof(inf), lblKO);
        ret = info(&inf);
        CHECK(ret >= 0, lblKO);
        switch (ret) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
              val = ret - '0';
              break;
          case kbdVAL:
              goto lblEnd;
          case kbdANN:         //Cancel
              MAPPUTBYTE(key, savVal, lblKO);
              goto lblEnd;
          case kbdCOR:
              val = 0;
              break;
          default:
              break;
        }
        MAPPUTBYTE(key, val, lblKO);
        ret = dspClear();
        CHECK(ret >= 0, lblKO);
    }
    ret = kbdVAL;
    goto lblEnd;
  lblKO:
    ret = -1;
  lblEnd:
    trcFN("scrKeyEntry: ret=%d\n", ret);
    return ret;
}

/** Retrieve user screen from database to display with data entry.
 * \return      
 * \param    infKey (I-) User screen structure.
 * \param    prmKey (I-) Data key.
 * \header log\\str.h
 * \source log\\scr.c 
*/
int scrDlg(word infKey, word prmKey) {
    int ret;

    VERIFY(infKey);
    VERIFY(prmKey);
    ret = dspClear();
    CHECK(ret >= 0, lblKO);

    switch (infKey) {
//      case infNewPwdInput:
//        ret = scrPwd();
//        CHECK(ret >= 0, lblKO);2
//        break;
      case infTMSRefNum:
      case infTMSNii:
      case infTMSPrimaryPhone:
      case infTMSSecondaryPhone:
      case infTMSPriPort:
      case infTMSSecPort:
      case infTMSGPRSPriPort:
      case infTMSGPRSSecPort:
      case infScrGprsPhone:
          ret = bgdInfo(infKey);
          CHECK(ret >= 0, lblKO);
          ret = scrNumEntry(prmKey, 0);
          CHECK(ret >= 0, lblKO);
          break;
      case infSetTraceNum:
      case infSetStan:
      case infEnterTrace:
      case infEnterAppCod:
      case infPabx:
      case infSetBatchNum:
          ret = bgdInfo(infKey);
          CHECK(ret >= 0, lblKO);
          ret = scrNumEntry(prmKey, lenInvNum);
          CHECK(ret >= 0, lblKO);
          break;
      case infTMSPriIP:
      case infTMSSecIP:
      case infTMSGPRSPriIP:
      case infTMSGPRSSecIP:
      case infScrIpAdd:
      case infScrSubMask:
      case infScrGateway:
          ret = bgdInfo(infKey);
          CHECK(ret >= 0, lblKO);
          ret = scrTcpIpEntry(prmKey);
          CHECK(ret >= 0, lblKO);
          break;
      case infTMSBufferSize:
      case infTMSHostLink:
      case infTMSBaudRate:
      case infScrEnableDhcp:
      case infScrTonePulse:
      case infScrToneDetect:
      case infConnMethod:
      case infScrGprsOnOff:
      case infPortSetting:
      case infRs232BaudRate:
      case infBlowfishMethod:  	
  	
          ret = scrKeyEntry(infKey, prmKey);
          CHECK(ret >= 0, lblKO);
          break;
      default:
          ret = -1;
          goto lblKO;
    }
    goto lblEnd;
  lblKO:
    ret = -1;
  lblEnd:
    trcFN("scrDlg: ret=%d\n", ret);
    return ret;
}
