#include "SDK30.H"
#include "log.h"
#include <string.h>
#include "sys.h"
#include "pri.h"
#include "_emvdctag_.h"
#include "bri.h"
#include "prepaid.h"
#include "lineEncryption.h"

#include "logon.h" //@@AS0.0.26
#include "keyinject.h"
#define ISO_BUFFER_LEN 2048 //@agmr

#ifdef TEST_BRI
void testScrollDisplay8();
#endif

extern void tcan0020();

#ifdef LINE_ENCRYPTION
void hex_dump(char *title,void *src,int len) { //@@AS0.0.10
	hex_dump_char(title,src,len);
}
#endif //LINE_ENCRYPTION

int enterHuruf(const char *title, byte len,char *buf)
{
	int ret;
	char dest[256];

	MEM_ZERO(dest);

	dspLS(2, title);
	ret = enterTxt3(3, dest, len, 0xFF);
	CHECK(ret == kbdVAL || ret > 0, lblKO);

	memcpy(buf, dest, strlen(dest));

	lblKO:
		return -1;
}

int enterUang(const char *title, byte len, char *buf)
{
	int ret;
	byte exp;
	char dest[256];

	MEM_ZERO(dest);

	dspLS(2, title);
	MAPGETBYTE(appExp, exp, lblKO);
	ret = enterAmt(3, (char *)dest, exp);
	CHECK(ret == kbdVAL || ret > 0, lblKO);

	memcpy(buf, dest, strlen(dest));

	return ret;
	lblKO:
		return -1;
}

int enterAngka(const char *title, byte len,char *buf)
{
	int ret;
	char dest[256];

	MEM_ZERO(dest);

	dspLS(2, title);
	ret = enterStr(3, dest, len+1);
	CHECK(ret == kbdVAL || ret > 0, lblKO);

	memcpy(buf, dest, strlen(dest));

	return 1;
	lblKO:
		return -1;
}

int pmtPrepare(byte trtType)
{
	int ret;
	char traName[dspW + 1];

	mapMove(rqsBeg, (word) trtType - 1);
	MAPGET(rqsDisp, traName, lblKO);

	MAPPUTSTR(traTransType, traName, lblKO);
	MAPPUTSTR(traTypeName, traName, lblKO);
	MAPPUTBYTE(traTxnType, trtType, lblKO);
	MAPPUTBYTE(traTxnId, trtType, lblKO);

	return ret;
	lblKO:
		return -1;
}

int  pmtPinManual(void) { //from duwi
	char Pan[lenPan + 1];       // Primary account number
	char pwd[6 + 1];
	int ret;
	int len;
	char data[2];
	char blok1[16+1];
	char blok2[16+1];
	char dataXor[8+1];
	byte blok1Byte[8+1];
	byte blok2Byte[8+1];
	char tmk[16+1];
	char tpk[16+1];
	char dataKey[8+1];
	char tmkByte[8 + 1];
	char tpkByte[8 + 1];
	char dataPin[8+1];

	trcS("pmtPinManual Beg\n");
	MEM_ZERO(Pan);
	MEM_ZERO(pwd);
	MEM_ZERO(blok1);
	MEM_ZERO(blok2);
	MEM_ZERO(dataXor);
	MEM_ZERO(tmk);
	MEM_ZERO(tpk);
	MEM_ZERO(tmkByte);
	MEM_ZERO(tpkByte);

	MAPGET(traPan, Pan, lblKO);

	dspClear();
	dspLS(2,"INPUT PIN ?");
	ret = enterPwd(3, pwd, 7);
    	CHECK(ret >= 0, lblKO);
    	CHECK(ret == kbdVAL, lblEnd);
	len = strlen(pwd);
	num2dec(data, len, 2);
	fmtPad(data, -2, 0x30);
	memcpy(blok1, data, 2);
	memcpy(blok1 + 2, pwd, len);
	fmtPad(blok1, 16, 0x46);

	memcpy(blok2, "0000", 4);
	memcpy(blok2 + 4, Pan + 3, 12);
       hex2bin(blok1Byte, blok1, 8);
	hex2bin(blok2Byte, blok2, 8);
	xor(blok1Byte, blok2Byte, dataXor, 8);

       memcpy(dataKey,"\x11\x11\x11\x11\x11\x11\x11\x11", 8);

	stdDES(dataPin, dataXor, dataKey);		//encrypt
	ret = mapPut(traPinBlk, dataPin, lenPinBlk);
       CHECK(ret >= 0, lblKO);

	return ret;
	lblKO:
	lblEnd:
	return -1;
}

int debug_set()
{
	char buf[2];
	int ret;
	memset(buf,0,sizeof(buf));
	dspClear();
	dspLS(1, "DEBUG REQUEST");
	dspLS(2, "1 - ON, 0 - OFF");
	ret = enterStr(3, buf, 2);
	if(buf[0] == 0x31)
	{	debugReqFlag = 1;
		dspClear();
		dspLS(1, "    DEBUG ON    ");
	}
	else
	{	debugReqFlag = 0;
		dspClear();
		dspLS(1, "    DEBUG OFF   ");
	}
	tmrPause(1);
	memset(buf,0,sizeof(buf));
	dspClear();
	dspLS(1, "DEBUG RESPONSE");
	dspLS(2, "1 - ON, 0 - OFF");
	ret = enterStr(3, buf, 2);
	if(buf[0] == 0x31)
	{	debugRspFlag = 1;
		dspClear();
		dspLS(1, "    DEBUG ON    ");
	}
	else
	{	debugRspFlag = 0;
		dspClear();
		dspLS(1, "    DEBUG OFF   ");
	}
	tmrPause(1);
	return 1;
}

char acceptable_key(int accept_key, int timeout)
	{
		char key, key1, key2;
		int tOut;

		kbdStart(1);

		tmrStart(0, timeout * 100); //60 seconds timeout for user reaction
		kbdStart(1);

		switch(accept_key)
		{
			case kbdF1_kbdF4:
				key1 = kbdF1;
				key2 = kbdF4;
				break;

			case kbdVAL_kbdANN:
				key1 = kbdANN;
				key2 = kbdVAL;
				break;
		}

		tOut = tmrGet(0);

		while(tOut != 0)
		{
			tOut = tmrGet(0);
			key = kbdKey(); 	//retrieve the key pressed if any
			if(key == key1 || key == key2)
				break;		//quit the loop if the key is pressed
		}

		kbdStop();
		tmrStop(0);

		if (tOut == 0)
		{
			usrInfo(infConnTimeout);
			//Beep();
			return key1; // cancel
		}

		return key;
	}

int display_text(int line, int y, char *text, int alignment) {
	int ret, col;
	int wdt = 21;

	font_size(6, 8);
	switch(alignment)
	{
		case dsp_ALIGN_LEFT://left
		gotoxy(line, y); ret = printf(text); CHECK(ret>=0, lblKO);
		break;

		case dsp_ALIGN_CENTER://center
		col = (wdt - strlen(text)) / 2;
		gotoxy(line, col + y); ret = printf(text); CHECK(ret>=0, lblKO);
		break;

		case dsp_ALIGN_RIGHT://right
		col = wdt - strlen(text);
		gotoxy(line, col); ret = printf(text); CHECK(ret>=0, lblKO);
		break;
	}

	return ret;
	lblKO:
		return -1;
}


	/*
	**	@author:	EQ
	**	@date:		2009-09-29
	**	@version:	1.0
	**	@desc:		Get key pressed with timeout
	**
	**	@param		time out in second
	**
	*/
char udf_get_key_press(int timeout)
	{
		char key;
		int tOut;

		kbdStart(1);

		tmrStart(0, timeout * 100); //60 seconds timeout for user reaction
		kbdStart(1);

		tOut = tmrGet(0);

		while(tOut != 0)
		{
			tOut = tmrGet(0);
			key = kbdKey(); 	//retrieve the key pressed if any
			if(key) break;		//quit the loop if the key is pressed
		}

		kbdStop();
		tmrStop(0);

		if (tOut == 0)
		{
			usrInfo(infConnTimeout);
			Beep();
			return '\0';
		}

		return key;
	}

void PrintInit()
{
    int ret;
    byte counter = 0;
    char AcqName[lenName + 1];
    char Aid[lenAID + 1];

	ret = rptReceipt(rloInitHeader);
    	CHECK(ret >= 0, lblKO);
    	for (counter = 0; counter < dimAcq; counter++) {
        mapMove(acqBeg, counter);
        MAPGET(acqName, AcqName, lblKO);
        if(AcqName[0] == 0)
            break;
        ret = rptReceipt(rloInitBody);
        CHECK(ret >= 0, lblKO);
    }
    ret = rptReceipt(rloInitEmvHeader);
    CHECK(ret >= 0, lblKO);
    for (counter = 0; counter < dimAID; counter++) {
        mapMove(aidBeg, counter);
        MAPGET(emvAid, Aid, lblKO);
        if(Aid[0] == 0)
            break;
        ret = rptReceipt(rloInitEmvBody);
        CHECK(ret >= 0, lblKO);
    }
	ttestall(0,300);
	lblKO:
		;
}

void isIct220()
{
	char buf[2];
	int ret;
	memset(buf,0,sizeof(buf));
	dspClear();
	dspLS(1, "ICT 220 SET");
	dspLS(2, "1 - ON, 0 - OFF");
	ret = enterStr(3, buf, 2);
	if(buf[0] == 0x31)
	{
		MAPPUTBYTE(appICT220, 1, lblEnd)
		dspClear();
		dspLS(1, "   ICT 220 ON   ");
	}
	else
	{
		MAPPUTBYTE(appICT220, 0, lblEnd)
		dspClear();
		dspLS(1, "   ICT 220 OFF  ");
	}
	tmrPause(1);
	lblEnd:
		;

}

void AcquirerInfo()
{
	int counter = 0;
	int ret;
	char AcqName[lenName + 1];
	char prim_ip[32+1];
	char Nii[lenNII + 1];
	char TID[lenTid + 1];
	char MID[lenMid + 1];
	char key;

	while(counter < dimAcq)
	{
	       mapMove(acqBeg, counter);
	       MAPGET(acqName, AcqName, lblKO);
	        if(AcqName[0] == 0)
	           break;
	       MAPGET(acqPriTxnIPSrv, prim_ip, lblKO);
		MAPGET(acqNII, Nii, lblKO);
		MAPGET(acqTID, TID, lblKO);
		MAPGET(acqMID, MID, lblKO);
	       dspClear();
		display_text(0, 0, 	AcqName, 		dsp_ALIGN_CENTER);
		display_text(1, 0, 	"IP:", 			dsp_ALIGN_LEFT);
		display_text(2, 0, 	prim_ip, 			dsp_ALIGN_LEFT);
		display_text(3, 0, 	"NII:", 			dsp_ALIGN_LEFT);
		display_text(3, 4, 	Nii, 				dsp_ALIGN_LEFT);
		display_text(4, 0, 	"TID:", 			dsp_ALIGN_LEFT);
		display_text(4, 4, 	TID,				dsp_ALIGN_LEFT);
		display_text(5, 0, 	"MID:", 			dsp_ALIGN_LEFT);
		display_text(5, 4, 	MID, 			dsp_ALIGN_LEFT);
		display_text(7, 0, 	"Next", 			dsp_ALIGN_RIGHT);
		key = acceptable_key(kbdF1_kbdF4, 60);
		if(key == kbdF1)
			counter--;
		else
			counter++;
    }

	lblKO:
		;
}

void CetakMasterKey()
{
	int counter = 0;
	int ret;
	char AcqName[lenName + 1];
	char MKey[lenMKey + 1];
	//char key;

	while(counter < dimAcq)
	{
	       mapMove(acqBeg, counter);
	       MAPGET(acqName, AcqName, lblKO);
	        if(AcqName[0] == 0)
	           break;
	      // MAPGET(acqMasterKey, MKey, lblKO);
		hex_dump_char("MKey", MKey, lenMKey);
    }

	lblKO:
		;
}

void hexDumpTMS(void)
{
	char TACDft[6+1];
	char TACDen[6+1];
	char TACOnl[6+1];

	char TACDfth[10+1];
	char TACDenh[10+1];
	char TACOnlh[10+1];
	int counter = 0;
	char key;
	int ret;

	while(counter < dimAID)
	{
		MEM_ZERO(TACDft);
		MEM_ZERO(TACDen);
		MEM_ZERO(TACOnl);

       	mapMove(aidBeg, counter);
		MAPGET(emvTACDft, TACDft, lblKO);
		MAPGET(emvTACDen, TACDen, lblKO);
		MAPGET(emvTACOnl, TACOnl, lblKO);

		bin2hex(TACDfth, TACDft+1, 5);
		bin2hex(TACDenh, TACDen+1, 5);
		bin2hex(TACOnlh, TACOnl+1, 5);

		dspClear();
		display_text(1, 0, 	"TAC Default:", 	dsp_ALIGN_LEFT);
		display_text(2, 0, 	TACDfth, 			dsp_ALIGN_LEFT);
		display_text(3, 0, 	"TAC Denial:",		dsp_ALIGN_LEFT);
		display_text(4, 0, 	TACDenh, 			dsp_ALIGN_LEFT);
		display_text(5, 0, 	"TAC Online:",  	dsp_ALIGN_LEFT);
		display_text(6, 0, 	TACOnlh,			dsp_ALIGN_LEFT);
		display_text(7, 0, 	"Next", 			dsp_ALIGN_RIGHT);
		key = acceptable_key(kbdF1_kbdF4, 60);
		if(key == kbdF1)
			counter--;
		else
			counter++;
    }

	lblKO:
		;

	}


int CheckFallBack(int ret)
{
unsigned char FallBack;

switch(ret) //Bao add
		{
		case TAG_PROCESS_COMPLETED:
			break;
	    case TAG_PROCESSING_ERROR: //17
	    case TAG_CARD_ERROR:
	    case TAG_CDA_FAILED:
	    case TAG_NOT_ACCEPTED:
	    case TAG_ICC_DATA_FORMAT_ERROR:
	    case TAG_MISSING_MANDATORY_ICC_DATA:
	    case TAG_ICC_REDUNDANT_DATA:
	    case TAG_MISSING_MANDATORY_TERM_DATA:
	    case TAG_INTERNAL_ERROR:
	    case TAG_SERVICE_NOT_ALLOWED:
	    case TAG_NOT_ENOUGH_MEMORY:
	    case TAG_WRONG_DEL_INPUT_PARAMETER:
			mapGetByte(traFallback, FallBack);
			if(emvGetFallBack() || (FallBack == 1))
			{
				return 1;
			}
		default:
			return 0;
		}
	return 0;
}

#if 0
static int testDial(byte ctl) {
    const char *ptr;

    ptr = 0;
    switch (ctl) {
      case 0:
          ptr = "192.168.0.1|5030";
          break;
      case 1:
          ptr = "10.10.59.27|2000";
          break;
      case 2:
          ptr = "82.247.161.69|6789";
          break;
      default:
          break;
    }
    VERIFY(ptr);
    return comDial(ptr);
}
#endif

void pmtEchoTest(void) {
	int ret;
	char traName[dspW + 1];


	trcS("pmtEchoTest Beg\n");

//    ret = selectAcquirer();
//    if(ret <= 0)
//        goto lblKO;

    mapMove(acqBeg,0);

	mapMove(rqsBeg, (word) (trtEchoTest- 1));
	MAPGET(rqsDisp, traName, lblKO);
	trcFS("traName: %s\n", traName);

    MAPPUTBYTE(regLocType,'T',lblKO);
	MAPPUTSTR(traTransType, traName, lblKO);
	MAPPUTSTR(traTypeName, traName, lblKO);
	MAPPUTBYTE(traTxnType, trtEchoTest, lblKO);
	MAPPUTBYTE(traTxnId, rqtEchoTest, lblKO);

	ret = onlSession();
	CHECK(ret > 0, lblKO);

	ret = valRspCod();
	CHECK(ret > 0, lblKO);

	ret = 1;
	goto lblEnd;

lblKO:
    return;
lblEnd:
    trcS("pmtEchoTest End\n");

}


void PrintIsoMsg()
{
	int ret;
	char req[ISO_BUFFER_LEN];
	word lenreq;
	word lenrsp;
	char rsp[ISO_BUFFER_LEN];
	char buf[2];

	ret = valAskPwd(appPassTel);
	CHECK((ret > 0) && (ret != kbdANN), lblEnd);

		memset(buf,0,sizeof(buf));
		dspClear();
		dspLS(1, "0 -> RESPONSE");
		dspLS(2, "1 -> REQUEST");
		ret = enterStr(3, buf, 2);
		CHECK(ret != kbdANN, lblEnd);
		if(buf[0] == 0x31)
		{
			MAPGET(appRequest, req, lblKO);
			MAPGETWORD(appReqLen, lenreq, lblKO);
			hex_dump_char("Request", req, lenreq);
		}
		else
		{	MAPGET(appRespon, rsp, lblKO);
			MAPGETWORD(appRspLen, lenrsp, lblKO);
			hex_dump_char("Response", rsp, lenrsp);
		}
		tmrPause(1);

	goto lblEnd;
	lblKO:
		usrInfo(infDataAccessError);
	lblEnd:
		trcS("tes");
}


int debug_emv_set()
{
	char buf[2];
	int ret;
	memset(buf,0,sizeof(buf));
	dspClear();
	dspLS(1, "DEBUG EMV");
	dspLS(2, "1 - ON, 0 - OFF");
	ret = enterStr(3, buf, 2);
	if(buf[0] == 0x31)
	{	debugEmvFlag = 1;
		dspClear();
		dspLS(1, "    DEBUG ON    ");
	}
	else
	{	debugEmvFlag = 0;
		dspClear();
		dspLS(1, "    DEBUG OFF   ");
	}
	tmrPause(1);

	return 0;
}

void ICCDebug()
{
	rptReceipt(rloEmvDebug);
	ttestall(0, 300);
}
void call_function(int nbr_func)
{
	switch(nbr_func)
	{
		case 0:
			pmtEchoTest();
			break;
		case 1:
			PrintInit();
			break;
//		case 2:
//			hexDumpTMS();
//			break;
		case 3:
			PrintIsoMsg();
			break;
//		case 4:
//			debug_set();
//			break;
//		case 5:
//			CetakMasterKey();
//			break;
//		case 6:
//			debug_emv_set();
//			break;
//		case 7:
//			ICCDebug();
//			break;
		case 2:
			AcquirerInfo();
			break;
		case 11:
#ifdef TEST_BRI
		    testScrollDisplay8();
#endif
		    break;

		case 37: //@@AS0.0.20
			debug_emv_set();
			break;

#ifdef LINE_ENCRYPTION
		case 80:
		    tleMenu();
//			tleProcess(0);
			break;
#endif //LINE_ENCRYPTION

		case 81:
			debitLogon(0,1);
			break;
			
#ifdef DUMP_ISO_MESSAGE
	    case 93:
			setDumpIsoMessage();
			break;
#endif

#ifdef DEBUG_PREPAID_DATA
		case 94:
		    setDebugData();
		    break;
#endif

		case 95:
		FnTerminal();
		break;
		case 96:
		FnTMS();
		break;
		case 97:
		FnCommunication();
		break;
		case 98:
		FnConnSetting();
		break;
		case 99:
		Fn99();
		break;


		case 101:
			req4Key(); // inject mkwk
			break;


#ifdef TEST_BRI
          case 30:
            testReprintLastMiniAtm();
            break;
          case 40:
            testReprintMiniAtm();
            break;
          case 50:
            testPrintDetail();
            break;
//          case 60:
//            viewCardServiceLog();
//          	break;
//          case 61:
//        	viewMiniAtmLog();
//          	break;
//          case 62:
//        	viewTunaiLog();
//          	break;
          case 70:
        	testPrintTotal();
          	break;
          case 71:
        	  testPrintTotalHariIni();
          	break;
          case 72:
        	testPrintTotalHariSemua();
          	break;
          case 90:
            testBacaLogSemua();
            break;
#ifdef PREPAID
		  case 110:
		    testPrepaidInit();
		    break;
		  case 111:
		    testInfoSaldo();
		    break;
		  case 112:
		    testPrepaidSale();
		    break;

#endif
#endif //TEST_BRI

		  case 100:
		  	Fn100();
		  	break;

//		  case 10:
//		    viewLog();
//		    break;
	}

}

int displayResponse(void){
     char RspCod[lenRspCod + 1];
     byte txnType;
     int ret;

	dspClear();

	 MAPGET(traRspCod, RspCod, lblKO);
	 CHECK(ret >= 0, lblKO);

	MAPGETBYTE(traTxnType,txnType,lblKO);
	switch(txnType)
	{
	    case trtEchoTest:
	        if(strcmp(RspCod,"00") == 0)
	        {
	            usrInfo(infTestKoneksiBerhasil);
	        }
	        break;
		case trtTransferAntarBankInquiry:
			if(strcmp(RspCod, "68") == 0)
            {
            	usrInfo(infRsp68Transfer);
                return 0;
            }break;
		case trtTransferAntarBank:
			if(strcmp(RspCod, "68") == 0)
            {
            	usrInfo(infRsp68Transfer);
                return 9999;
            }break;
		case trtReissuePIN:
	        if(strcmp(RspCod, "60") == 0)
	        {
	 	        usrInfo(infRsp60RekeningSalah);
	 	        return 0;
	 	    }
		case trtGantiPIN:
		case trtGantiPasswordSPV:
			if(strcmp(RspCod, "16") == 0)
            {
            	usrInfo(infRsp16CardServ);
                return 0;
            }else if(strcmp(RspCod, "IP") == 0)
            {
            	usrInfo(infRspIP);
                return 0;
            }else if(strcmp(RspCod, "09") == 0)
            {
            	usrInfo(infRsp09);
                return 0;
            }
            break;
	    case trtAktivasiKartuOtorisasi:
	    case trtRenewalKartuOtorisasi:
	    case trtReissuePINOtorisasi:
            if(strcmp(RspCod, "00") == 0)
            {
            // usrInfo(infOtorisasiBerhasil);
                return 9999;
            }else if(strcmp(RspCod, "IP") == 0)
            {
            	usrInfo(infRspIP);
                return 0;
            }else if(strcmp(RspCod, "09") == 0)
            {
            	usrInfo(infRsp09);
                return 0;
            }
            break;
	    case trtAktivasiKartuInquiry:
	    case trtRenewalKartuInquiry:
    	    if(strcmp(RspCod, "00") == 0)
                return 9999;
        case trtRenewalKartu:
        case trtAktivasiKartu:
            if(strcmp(RspCod, "NC") == 0)
            {
                usrInfo(infRenewalBerhasilPINGagal);
                return 1;
            }else if(strcmp(RspCod, "IP") == 0)
            {
            	usrInfo(infRspIP);
                return 0;
            }else if(strcmp(RspCod, "09") == 0)
            {
            	usrInfo(infRsp09);
                return 0;
            }
	        else if(strcmp(RspCod, "60") == 0)
	        {
	 	        usrInfo(infRsp60RekeningSalah);
                return 0;
	        }
            break;
		/*Changed By Ali*/
		case trtRegistrasiSmsBanking:
		/*End Of Changed By Ali*/            
        case trtRegistrasiInternetBanking:
        	if(strcmp(RspCod, "64") == 0)
            {
            	usrInfo(infRsp64IBank);
                return 0;
            }
            break;
        case trtPembayaranCicilanInquiry:
        	if(strcmp(RspCod, "14") == 0)
        	{
        		usrInfo(infRsp14Cicilan);
        		return 0;
        	}
        	break;
    	case trtPembayaranPascaBayarInquiry:
		case trtPembayaranPascaBayar:
		case trtPembayaranPulsa:
        	if(strcmp(RspCod, "14") == 0)
        	{
        		usrInfo(infRsp14Pulsa);
        		return 0;
        	}
        	break;
        case trtTarikTunai:
       	case trtInfoSaldo:
        	if(strcmp(RspCod, "53") ==0)
        	{
        		usrInfo(infRsp53Tunai);
        		return 0;
        	}
        	break;
       	
        case trtPembayaranPLN:
        case trtPembayaranPLNInquiry:
/*
00 : sukses
04: IDPEL YANG ANDA MASUKKAN SALAH MOHON TELITI KEMBALI
06: Pembayaran Gagal
13: Invalid Amount
14: ID PLN Tidak Ditemukan
89 : Koneksi ke Pihak Ketiga Putus
68: Koneksi ke Pihak Ketiga Time Out
88: Tidak Ada Tagihan
08: Tagihan Bulan Berjalan Tidak Tersedia.
*/
            if(strcmp(RspCod, "06") == 0)
            {
                usrInfo(infRsp06Pln);
        		return 0;
            }

            if(strcmp(RspCod, "04") == 0)
            {
                usrInfo(infRsp04Pln);
        		return 0;
            }

            if(strcmp(RspCod, "08") == 0)
            {
                char buf[30];
                char str[30];
                card tmp;

                memset(buf,0,sizeof(buf));
                MAPGET(traRspBit13,buf,lblKO);
                memset(str,0,sizeof(str));
                bin2hex(str, buf, 1);
                tmp = (str[0]-0x30)*10 + (str[1]-0x30);
                memset(buf,0,sizeof(buf));
                convertBulan(1,buf,(byte)tmp);
                memset(str,0x20,16);
                memcpy(str+((16-strlen(buf))/2),buf,strlen(buf));
                dspLS(1,str);
                usrInfo(infRsp08Pln);
        		return 0;
            }
            if(strcmp(RspCod, "13") == 0)
            {
                usrInfo(infRsp13Pln);
        		return 0;
            }
            if(strcmp(RspCod, "14") == 0)
            {
                usrInfo(infRsp14Pln);
        		return 0;
            }
            if(strcmp(RspCod, "68") == 0)
            {
                usrInfo(infRsp68PascaByr);
        		return 0;
            }
            if(strcmp(RspCod, "88") == 0)
            {
                usrInfo(infRsp88);
        		return 0;
            }
            if(strcmp(RspCod, "89") == 0)
            {
                usrInfo(infRsp89PascaByr);
        		return 0;
            }
		default:
            break;
	}
	
#ifdef PREPAID
    if(isPrepaidTransaction(1) == 1)
    {
        if(strcmp(RspCod, "05") == 0)
            {usrInfo(infRspPrepaid05);return 0;}
        if(strcmp(RspCod, "NF") == 0)
            {usrInfo(infRspPrepaidNF);return 0;}
        if(strcmp(RspCod, "UI") == 0)
            {usrInfo(infRspPrepaidUI);return 0;}
        if(strcmp(RspCod, "62") == 0)
            {usrInfo(infRspPrepaid62);return 0;}
        if(strcmp(RspCod, "OV") == 0)
            {usrInfo(infRspPrepaidOV);return 0;} 
        if(strcmp(RspCod, "ZB") == 0)
            {usrInfo(infRspPrepaidZB);return 0;}
        if(txnType == trtPrepaidRedeemInquiry)
        {
            if(memcmp(RspCod,"\x00\x00",2)==0)
                return 0;
        }
    }
#endif
	
	if (txnType==trtDebitLogon) //@@AS0.0.26 : no need to diplay response for logon
		return 0;
			
	if(strcmp(RspCod, "00") == 0)
	{
// @@OA - mulai
		if(isBRIInquiryTransaction() || txnType==trtTLEKeyDownload)
		    return 0;
// @@OA - selesai
		usrInfo(infApprove);
		return 1;
	}
	else if(strcmp(RspCod, "01") == 0)
	 	usrInfo(inf01Declined);
	else if(strcmp(RspCod, "05") == 0)
	 	usrInfo(infRsp05);
	else if(strcmp(RspCod, "10") == 0)
		usrInfo(infRsp10);
	else if(strcmp(RspCod, "25") == 0)
	 	usrInfo(infRsp25);
	else if(strcmp(RspCod, "34") == 0)
	 	usrInfo(infRsp34);
	else if(strcmp(RspCod, "38") == 0)
	 	usrInfo(infRsp38);
	else if(strcmp(RspCod, "41") == 0)
	 	usrInfo(infRsp41);
	else if(strcmp(RspCod, "50") == 0)
	 	usrInfo(infRsp50);
	else if(strcmp(RspCod, "51") == 0)
	    usrInfo(inf51Declined);
	else if(strcmp(RspCod, "53") == 0)
	    usrInfo(infRsp53);
	else if(strcmp(RspCod, "54") == 0)
	 	usrInfo(infCardExpired);
	else if(strcmp(RspCod, "59") == 0)
	 	usrInfo(infRsp59);
	else if(strcmp(RspCod, "61") == 0)
	 	usrInfo(infRsp61OverLimit);
	else if(strcmp(RspCod, "68") == 0)
        usrInfo(infRsp68PascaByr);
    else if(strcmp(RspCod, "88") == 0)
	 	usrInfo(infRsp88);
	else if(strcmp(RspCod, "89") == 0)
    	usrInfo(infRsp89PascaByr);
    else if((strcmp(RspCod, "Q4") == 0) || (strcmp(RspCod, "q4") == 0))
		usrInfo(infRspQ4);
	else if((strcmp(RspCod, "Q1") == 0) || (strcmp(RspCod, "q1") == 0))
		usrInfo(infRspQ1);
	else
		usrInfo(infOnlineResult);

	return 0;

	lblKO:
		return -1;
}

void FmtExpDat(char *dst, char *src)//For format expdat 20100820
{
	char ExpDatFmt[lenExpDat + 1];

	memcpy(ExpDatFmt, src, 2);//For receipt
	ExpDatFmt[2] = '/';
	memcpy(ExpDatFmt + 3, src +2, 2);
	memcpy(dst, ExpDatFmt, 5);
}

#ifdef TEST_BRI
void testScrollDisplay8()
{
    int ret;
//    char str[128];
    char buf[128];//,buf1[128];
    char judul[30];
    char baris1[30];char baris2[30];
//    byte key;
    char msg[10][21];
    int i=0;

    memset(msg,0,sizeof(msg));
    strcpy(judul,"AKTIVASI KARTU");
    //nomor kartu
    memset(buf,0,sizeof(buf));
    strcpy(msg[i++],"Nomor Kartu:");
    strcpy(msg[i++],"1234567890123456");

    //nomor rekening
    memset(buf,0,sizeof(buf));
    mapGet(traNomorRekeningAsalBRI,buf,sizeof(buf));
    trimRight(buf,0x20);
    strcpy(msg[i++],"Nomor Rekening:");
    strcpy(msg[i++],"22223333444455566");

    //Nama nasabah
    memset(buf,0,sizeof(buf));
    mapGet(traNamaPenerima,buf,30);
    trimRight(buf,0x20);
    strcpy(buf,"NAMA NAMA NAMA NAMA  NAMA12345");
    ret = displayLongText(buf, strlen(buf), baris1, baris2, 20);
    strcpy(msg[i++],"Nama:");
    strcpy(msg[i++],baris1);
    if(ret == 2)
        strcpy(msg[i++],baris2);

    //Tanggal lahi
    memset(buf,0,sizeof(buf));
    mapGet(traTanggalLahir,buf,lenTanggalLahir);
    strcpy(msg[i++],"Tgl Lahir:");
    strcpy(msg[i++],"01012000");

    ret = scrollDisplay8(msg,i,6,judul,"BATAL      LANJUT");
}
#endif

